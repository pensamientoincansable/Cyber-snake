<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>CYBER SNAKE - Nanobot Hunter</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            touch-action: none;
        }

        body {
            overflow: hidden;
            background: #000;
            font-family: 'Orbitron', 'Segoe UI', sans-serif;
            position: fixed;
            width: 100%;
            height: 100%;
        }

        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');

        #gameCanvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* HUD del juego */
        #ui {
            position: fixed;
            top: 10px;
            left: 10px;
            right: 10px;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            pointer-events: none;
            z-index: 100;
        }

        .hud-panel {
            background: linear-gradient(135deg, rgba(0, 255, 255, 0.04), rgba(0, 100, 150, 0.06));
            border: 1px solid rgba(0, 255, 255, 0.12);
            border-radius: 5px;
            padding: 3px 6px;
            backdrop-filter: blur(3px);
        }

        .score-display {
            color: rgba(0, 255, 255, 0.9);
            font-size: 14px;
            font-weight: 700;
            text-shadow: 0 0 8px rgba(0, 255, 255, 0.5);
            font-family: 'Orbitron', monospace;
        }

        .score-label {
            color: rgba(0, 255, 255, 0.5);
            font-size: 7px;
            letter-spacing: 1px;
            margin-bottom: 1px;
        }

        .level-display {
            color: rgba(255, 0, 255, 0.9);
            font-size: 14px;
            font-weight: 700;
            text-shadow: 0 0 8px rgba(255, 0, 255, 0.5);
        }

        .length-display {
            color: rgba(0, 255, 0, 0.9);
            font-size: 12px;
            font-weight: 700;
            text-shadow: 0 0 8px rgba(0, 255, 0, 0.5);
        }

        .nanobot-timer {
            position: fixed;
            top: 48px;
            right: 10px;
            background: linear-gradient(135deg, rgba(255, 0, 100, 0.05), rgba(150, 0, 100, 0.08));
            border: 1px solid rgba(255, 0, 150, 0.15);
            border-radius: 8px;
            padding: 2px 8px;
            color: rgba(255, 0, 255, 0.6);
            font-family: 'Orbitron', monospace;
            font-size: 7px;
            backdrop-filter: blur(3px);
            pointer-events: none;
        }

        .timer-bar {
            width: 50px;
            height: 3px;
            background: rgba(255, 255, 255, 0.15);
            border-radius: 2px;
            margin-top: 3px;
            overflow: hidden;
        }

        .timer-fill {
            height: 100%;
            background: linear-gradient(90deg, #f0f, #0ff);
            border-radius: 2px;
            transition: width 0.1s linear;
        }

        /* Bot√≥n de pausa */
        .pause-btn {
            position: fixed;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.05), rgba(255, 255, 255, 0.1));
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            padding: 8px 15px;
            color: rgba(255, 255, 255, 0.7);
            font-family: 'Orbitron', sans-serif;
            font-size: 12px;
            cursor: pointer;
            z-index: 150;
            transition: all 0.3s ease;
        }

        .pause-btn:hover, .pause-btn:active {
            background: linear-gradient(135deg, rgba(0, 255, 255, 0.2), rgba(255, 0, 255, 0.2));
            border-color: rgba(0, 255, 255, 0.5);
        }

        /* Pantallas de men√∫ */
        .menu-screen {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: radial-gradient(ellipse at center, rgba(0, 50, 80, 0.97), rgba(0, 10, 20, 0.99));
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 200;
            padding: 20px;
        }

        .menu-screen.hidden {
            display: none;
        }

        .title {
            font-family: 'Orbitron', sans-serif;
            font-size: clamp(28px, 8vw, 72px);
            font-weight: 900;
            background: linear-gradient(180deg, #0ff, #f0f);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            filter: drop-shadow(0 0 20px rgba(0, 255, 255, 0.8));
            margin-bottom: 10px;
            text-align: center;
            animation: titlePulse 2s ease-in-out infinite;
        }

        .title-small {
            font-size: clamp(20px, 5vw, 40px);
        }

        @keyframes titlePulse {
            0%, 100% { filter: drop-shadow(0 0 20px rgba(0, 255, 255, 0.8)); }
            50% { filter: drop-shadow(0 0 40px rgba(255, 0, 255, 0.9)); }
        }

        .subtitle {
            color: rgba(0, 255, 255, 0.8);
            font-size: clamp(12px, 3vw, 24px);
            letter-spacing: 5px;
            margin-bottom: 40px;
            font-family: 'Orbitron', sans-serif;
            text-align: center;
        }

        /* Botones del men√∫ */
        .menu-btn {
            background: linear-gradient(135deg, rgba(0, 255, 255, 0.15), rgba(255, 0, 255, 0.15));
            border: 2px solid rgba(0, 255, 255, 0.5);
            color: #0ff;
            padding: 15px 40px;
            font-size: clamp(12px, 3.5vw, 20px);
            font-family: 'Orbitron', sans-serif;
            font-weight: 700;
            cursor: pointer;
            border-radius: 30px;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 2px;
            margin: 8px 0;
            min-width: 250px;
            text-align: center;
        }

        .menu-btn:hover, .menu-btn:active {
            background: linear-gradient(135deg, rgba(0, 255, 255, 0.3), rgba(255, 0, 255, 0.3));
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.5);
            transform: scale(1.05);
        }

        .menu-btn.secondary {
            background: linear-gradient(135deg, rgba(255, 100, 0, 0.15), rgba(255, 0, 100, 0.15));
            border-color: rgba(255, 100, 50, 0.5);
            color: #ff6633;
        }

        .menu-btn.secondary:hover, .menu-btn.secondary:active {
            background: linear-gradient(135deg, rgba(255, 100, 0, 0.3), rgba(255, 0, 100, 0.3));
            box-shadow: 0 0 30px rgba(255, 100, 0, 0.5);
        }

        .menu-btn.danger {
            background: linear-gradient(135deg, rgba(255, 0, 0, 0.15), rgba(150, 0, 50, 0.15));
            border-color: rgba(255, 50, 50, 0.5);
            color: #ff4444;
        }

        .menu-btn.danger:hover, .menu-btn.danger:active {
            background: linear-gradient(135deg, rgba(255, 0, 0, 0.3), rgba(150, 0, 50, 0.3));
            box-shadow: 0 0 30px rgba(255, 0, 0, 0.5);
        }

        .menu-btn.small {
            padding: 10px 25px;
            font-size: clamp(10px, 2.5vw, 14px);
            min-width: 150px;
        }

        /* Selector de velocidad */
        .speed-selector {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 20px 0;
            width: 100%;
            max-width: 300px;
        }

        .speed-label {
            color: rgba(0, 255, 255, 0.8);
            font-family: 'Orbitron', sans-serif;
            font-size: clamp(12px, 3vw, 16px);
            margin-bottom: 15px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .speed-value {
            color: #f0f;
            font-family: 'Orbitron', sans-serif;
            font-size: clamp(14px, 3.5vw, 20px);
            font-weight: 700;
            margin-bottom: 10px;
            text-shadow: 0 0 10px #f0f;
        }

        .speed-slider {
            width: 100%;
            height: 8px;
            -webkit-appearance: none;
            appearance: none;
            background: linear-gradient(90deg, #0f0, #ff0, #f00);
            border-radius: 4px;
            outline: none;
            opacity: 0.9;
        }

        .speed-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 24px;
            height: 24px;
            background: linear-gradient(135deg, #0ff, #f0f);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.8);
            border: 2px solid #fff;
        }

        .speed-slider::-moz-range-thumb {
            width: 24px;
            height: 24px;
            background: linear-gradient(135deg, #0ff, #f0f);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.8);
            border: 2px solid #fff;
        }

        /* Lista de r√©cords */
        .records-list {
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.5), rgba(0, 50, 80, 0.3));
            border: 1px solid rgba(0, 255, 255, 0.3);
            border-radius: 15px;
            padding: 20px;
            margin: 20px 0;
            width: 100%;
            max-width: 350px;
            max-height: 300px;
            overflow-y: auto;
        }

        .record-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 15px;
            margin: 5px 0;
            background: linear-gradient(135deg, rgba(0, 255, 255, 0.05), rgba(255, 0, 255, 0.05));
            border-radius: 10px;
            border: 1px solid rgba(0, 255, 255, 0.15);
        }

        .record-item.gold {
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.2), rgba(255, 180, 0, 0.1));
            border-color: rgba(255, 215, 0, 0.5);
        }

        .record-item.silver {
            background: linear-gradient(135deg, rgba(192, 192, 192, 0.2), rgba(150, 150, 150, 0.1));
            border-color: rgba(192, 192, 192, 0.5);
        }

        .record-item.bronze {
            background: linear-gradient(135deg, rgba(205, 127, 50, 0.2), rgba(180, 100, 30, 0.1));
            border-color: rgba(205, 127, 50, 0.5);
        }

        .record-rank {
            font-family: 'Orbitron', sans-serif;
            font-size: clamp(14px, 3vw, 18px);
            font-weight: 700;
            color: #0ff;
            min-width: 30px;
        }

        .record-score {
            font-family: 'Orbitron', sans-serif;
            font-size: clamp(16px, 4vw, 22px);
            font-weight: 700;
            color: #f0f;
            text-shadow: 0 0 10px #f0f;
        }

        .record-date {
            font-family: 'Orbitron', sans-serif;
            font-size: clamp(8px, 2vw, 10px);
            color: rgba(255, 255, 255, 0.5);
        }

        .no-records {
            color: rgba(255, 255, 255, 0.5);
            font-family: 'Orbitron', sans-serif;
            font-size: clamp(12px, 3vw, 16px);
            text-align: center;
            padding: 30px;
        }

        /* Final score */
        .final-score {
            font-size: clamp(24px, 6vw, 48px);
            color: #f0f;
            font-family: 'Orbitron', sans-serif;
            margin: 20px 0;
            text-shadow: 0 0 20px #f0f;
        }

        .new-record {
            color: #ffd700;
            font-family: 'Orbitron', sans-serif;
            font-size: clamp(14px, 3.5vw, 20px);
            text-shadow: 0 0 15px #ffd700;
            animation: recordPulse 1s ease-in-out infinite;
            margin-bottom: 10px;
        }

        @keyframes recordPulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.7; transform: scale(1.1); }
        }

        /* Scanlines */
        .scanlines {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            background: repeating-linear-gradient(
                0deg,
                rgba(0, 0, 0, 0.03) 0px,
                rgba(0, 0, 0, 0.03) 1px,
                transparent 1px,
                transparent 3px
            );
            z-index: 300;
        }

        .level-up {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #0ff;
            font-size: clamp(24px, 6vw, 48px);
            font-family: 'Orbitron', sans-serif;
            font-weight: 900;
            text-shadow: 0 0 30px #0ff, 0 0 60px #f0f;
            opacity: 0;
            pointer-events: none;
            z-index: 250;
        }

        .level-up.active {
            animation: levelUpAnim 1.5s ease-out forwards;
        }

        @keyframes levelUpAnim {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
            20% { opacity: 1; transform: translate(-50%, -50%) scale(1.2); }
            80% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(1.5); }
        }

        .swipe-hint {
            position: fixed;
            bottom: 140px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255, 255, 255, 0.3);
            font-size: 9px;
            font-family: 'Orbitron', sans-serif;
            letter-spacing: 2px;
            pointer-events: none;
        }

        /* Controles t√°ctiles */
        .touch-controls {
            position: fixed;
            bottom: 20px;
            left: 20px;
            right: 20px;
            display: none;
            justify-content: space-between;
            align-items: flex-end;
            pointer-events: none;
            z-index: 150;
        }

        .touch-controls.visible {
            display: flex;
        }

        /* D-Pad */
        .dpad {
            position: relative;
            width: 140px;
            height: 140px;
            pointer-events: auto;
        }

        .dpad-btn {
            position: absolute;
            width: 44px;
            height: 44px;
            background: linear-gradient(145deg, rgba(0, 255, 255, 0.06), rgba(0, 150, 200, 0.1));
            border: 1px solid rgba(0, 255, 255, 0.15);
            border-radius: 10px;
            display: flex;
            justify-content: center;
            align-items: center;
            color: rgba(0, 255, 255, 0.4);
            font-size: 18px;
            cursor: pointer;
            transition: all 0.15s ease;
            backdrop-filter: blur(2px);
            box-shadow: 0 0 8px rgba(0, 255, 255, 0.08);
        }

        .dpad-btn:active, .dpad-btn.active {
            background: linear-gradient(145deg, rgba(0, 255, 255, 0.2), rgba(0, 200, 255, 0.25));
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.25);
            transform: scale(0.95);
            color: rgba(0, 255, 255, 0.7);
        }

        .dpad-up { top: 0; left: 50%; transform: translateX(-50%); }
        .dpad-down { bottom: 0; left: 50%; transform: translateX(-50%); }
        .dpad-left { left: 0; top: 50%; transform: translateY(-50%); }
        .dpad-right { right: 0; top: 50%; transform: translateY(-50%); }

        .dpad-center {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 30px;
            height: 30px;
            background: rgba(0, 255, 255, 0.08);
            border: 1px solid rgba(0, 255, 255, 0.15);
            border-radius: 50%;
        }

        /* Bot√≥n Turbo */
        .turbo-container {
            pointer-events: auto;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .turbo-btn {
            width: 65px;
            height: 80px;
            background: linear-gradient(180deg, 
                rgba(255, 100, 0, 0.08) 0%,
                rgba(255, 50, 100, 0.12) 40%,
                rgba(255, 0, 150, 0.15) 70%,
                rgba(200, 0, 100, 0.18) 100%
            );
            border: 1px solid rgba(255, 100, 50, 0.2);
            border-radius: 50% 50% 50% 50% / 60% 60% 40% 40%;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            transition: all 0.15s ease;
            box-shadow: 
                0 0 10px rgba(255, 100, 0, 0.1),
                inset 0 -8px 15px rgba(0, 0, 0, 0.1),
                inset 0 8px 15px rgba(255, 255, 255, 0.03);
            position: relative;
            overflow: hidden;
        }

        .turbo-btn::before {
            content: '';
            position: absolute;
            top: 10%;
            left: 20%;
            width: 25%;
            height: 20%;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            filter: blur(3px);
        }

        .turbo-btn:active, .turbo-btn.active {
            background: linear-gradient(180deg, 
                rgba(255, 200, 0, 0.25) 0%,
                rgba(255, 100, 50, 0.3) 40%,
                rgba(255, 50, 150, 0.35) 70%,
                rgba(255, 0, 100, 0.4) 100%
            );
            border-color: rgba(255, 255, 0, 0.4);
            transform: scale(0.95);
            box-shadow: 
                0 0 20px rgba(255, 200, 0, 0.25),
                inset 0 -8px 15px rgba(0, 0, 0, 0.15),
                inset 0 8px 15px rgba(255, 255, 255, 0.08);
        }

        .turbo-icon {
            font-size: 22px;
            color: rgba(255, 255, 255, 0.5);
            text-shadow: 0 0 8px rgba(255, 255, 0, 0.3);
            margin-bottom: 2px;
        }

        .turbo-text {
            color: rgba(255, 255, 255, 0.4);
            font-family: 'Orbitron', sans-serif;
            font-size: 8px;
            font-weight: 700;
            letter-spacing: 1px;
        }

        .turbo-label {
            color: rgba(255, 150, 50, 0.3);
            font-family: 'Orbitron', sans-serif;
            font-size: 7px;
            margin-top: 4px;
            letter-spacing: 1px;
        }

        .controls-info {
            margin-top: 30px;
            color: rgba(255, 255, 255, 0.6);
            font-size: clamp(10px, 2.5vw, 14px);
            text-align: center;
            line-height: 2;
        }

        .controls-info span {
            color: #0ff;
            font-weight: bold;
        }

    </style>
</head>
<body>
    <div id="gameCanvas"></div>
    
    <div class="scanlines"></div>
    
    <!-- HUD del juego -->
    <div id="ui" class="hidden">
        <div class="hud-panel">
            <div class="score-label">NANOBOTS</div>
            <div class="score-display" id="score">0</div>
        </div>
        <div class="hud-panel" style="text-align: center;">
            <div class="score-label">NIVEL</div>
            <div class="level-display" id="level">1</div>
        </div>
        <div class="hud-panel">
            <div class="score-label">LONGITUD</div>
            <div class="length-display" id="length">3</div>
        </div>
    </div>

    <button class="pause-btn hidden" id="pauseBtn">‚è∏ PAUSA</button>

    <div class="nanobot-timer hidden" id="nanobotTimer">
        <div>NANOBOT</div>
        <div class="timer-bar">
            <div class="timer-fill" id="timerFill"></div>
        </div>
    </div>

    <div class="level-up" id="levelUp">¬°NIVEL COMPLETADO!</div>
    <div class="swipe-hint hidden" id="swipeHint">DESLIZA O USA LAS FLECHAS</div>

    <!-- Controles t√°ctiles -->
    <div class="touch-controls" id="touchControls">
        <div class="dpad">
            <div class="dpad-center"></div>
            <button class="dpad-btn dpad-up" id="btnUp">‚ñ≤</button>
            <button class="dpad-btn dpad-down" id="btnDown">‚ñº</button>
            <button class="dpad-btn dpad-left" id="btnLeft">‚óÄ</button>
            <button class="dpad-btn dpad-right" id="btnRight">‚ñ∂</button>
        </div>

        <div class="turbo-container">
            <button class="turbo-btn" id="turboBtn">
                <span class="turbo-icon">‚ö°</span>
                <span class="turbo-text">TURBO</span>
            </button>
            <span class="turbo-label">MANTENER</span>
        </div>
    </div>

    <!-- MEN√ö PRINCIPAL -->
    <div class="menu-screen" id="mainMenu">
        <div class="title">CYBER SNAKE</div>
        <div class="subtitle">NANOBOT HUNTER</div>
        
        <button class="menu-btn" id="btnPlay">üéÆ JUGAR</button>
        <button class="menu-btn secondary" id="btnSpeed">‚ö° VELOCIDAD</button>
        <button class="menu-btn" id="btnRecords">üèÜ R√âCORDS</button>
        <button class="menu-btn danger" id="btnExit">üö™ SALIR</button>
        
        <div class="controls-info">
            <span>‚Üë ‚Üì ‚Üê ‚Üí</span> o <span>W A S D</span> para mover<br>
            <span>DESLIZA</span> o usa el <span>D-PAD</span> t√°ctil<br>
            <span>ü•ö TURBO</span> para velocidad x3
        </div>
    </div>

    <!-- MEN√ö DE VELOCIDAD -->
    <div class="menu-screen hidden" id="speedMenu">
        <div class="title title-small">‚ö° VELOCIDAD</div>
        
        <div class="speed-selector">
            <div class="speed-label">Velocidad de la serpiente</div>
            <div class="speed-value" id="speedValueDisplay">NORMAL</div>
            <input type="range" min="1" max="5" value="3" class="speed-slider" id="speedSlider">
        </div>
        
        <button class="menu-btn" id="btnSpeedBack">‚Üê VOLVER</button>
    </div>

    <!-- MEN√ö DE R√âCORDS -->
    <div class="menu-screen hidden" id="recordsMenu">
        <div class="title title-small">üèÜ R√âCORDS</div>
        
        <div class="records-list" id="recordsList">
            <div class="no-records">No hay r√©cords todav√≠a</div>
        </div>
        
        <button class="menu-btn danger small" id="btnClearRecords">üóë BORRAR R√âCORDS</button>
        <button class="menu-btn" id="btnRecordsBack">‚Üê VOLVER</button>
    </div>

    <!-- MEN√ö DE PAUSA -->
    <div class="menu-screen hidden" id="pauseMenu">
        <div class="title title-small">‚è∏ PAUSA</div>
        
        <div class="speed-selector">
            <div class="speed-label">Velocidad de la serpiente</div>
            <div class="speed-value" id="pauseSpeedValueDisplay">NORMAL</div>
            <input type="range" min="1" max="5" value="3" class="speed-slider" id="pauseSpeedSlider">
        </div>
        
        <button class="menu-btn" id="btnResume">‚ñ∂ CONTINUAR</button>
        <button class="menu-btn secondary" id="btnRestartPause">üîÑ REINICIAR</button>
        <button class="menu-btn danger" id="btnExitToMenu">üè† MEN√ö PRINCIPAL</button>
    </div>

    <!-- PANTALLA GAME OVER -->
    <div class="menu-screen hidden" id="gameOverScreen">
        <div class="title title-small">üíÄ GAME OVER</div>
        <div class="new-record hidden" id="newRecordText">üéâ ¬°NUEVO R√âCORD! üéâ</div>
        <div class="final-score">SCORE: <span id="finalScore">0</span></div>
        
        <button class="menu-btn" id="btnRestart">üîÑ REINICIAR</button>
        <button class="menu-btn secondary" id="btnGameOverMenu">üè† MEN√ö PRINCIPAL</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // ===== CONFIGURACI√ìN =====
        const SPEED_SETTINGS = {
            1: { name: 'MUY LENTA', speed: 400, fast: 130 },
            2: { name: 'LENTA', speed: 300, fast: 100 },
            3: { name: 'NORMAL', speed: 220, fast: 70 },
            4: { name: 'R√ÅPIDA', speed: 150, fast: 50 },
            5: { name: 'MUY R√ÅPIDA', speed: 100, fast: 35 }
        };

        let CONFIG = {
            CELL_SIZE: 1,
            SNAKE_SPEED: 220,
            FAST_SPEED: 70,
            NANOBOT_LIFETIME: 5000,
            GROWTH_THRESHOLD: 10,
            OBSTACLE_PER_LEVEL: 3
        };

        // ===== ESTADO DEL JUEGO =====
        let scene, camera, renderer;
        let snake = [];
        let direction = { x: 1, y: 0 };
        let nextDirection = { x: 1, y: 0 };
        let nanobot = null;
        let nanobotTimer = null;
        let nanobotStartTime = 0;
        let obstacles = [];
        let particles = [];
        let score = 0;
        let level = 1;
        let gridWidth, gridHeight;
        let gameRunning = false;
        let gamePaused = false;
        let lastMoveTime = 0;
        let currentSpeed = CONFIG.SNAKE_SPEED;
        let baseSpeed = CONFIG.SNAKE_SPEED;
        let gridFloor = null;
        let nebulaParticles = [];
        let currentSpeedLevel = 3;

        // Touch controls
        let touchStartX = 0;
        let touchStartY = 0;
        let touchThreshold = 30;

        // Snake colors
        const snakeColors = [
            0x00ffff, 0x00eeff, 0x00ddff, 0x00ccff, 0x00bbff,
            0x00aaff, 0x0099ff, 0x0088ff, 0x0077ff, 0x0066ff,
            0x0055ff, 0x0044ff, 0x0033ff, 0x0022ff, 0x0011ff
        ];

        // ===== GESTI√ìN DE R√âCORDS =====
        function getRecords() {
            const records = localStorage.getItem('cyberSnakeRecords');
            return records ? JSON.parse(records) : [];
        }

        function saveRecord(score) {
            const records = getRecords();
            const newRecord = {
                score: score,
                date: new Date().toLocaleDateString('es-ES'),
                level: level
            };
            records.push(newRecord);
            records.sort((a, b) => b.score - a.score);
            const top10 = records.slice(0, 10);
            localStorage.setItem('cyberSnakeRecords', JSON.stringify(top10));
            return top10[0].score === score && records.length > 1 || (records.length === 1);
        }

        function clearRecords() {
            localStorage.removeItem('cyberSnakeRecords');
            updateRecordsList();
        }

        function updateRecordsList() {
            const records = getRecords();
            const container = document.getElementById('recordsList');
            
            if (records.length === 0) {
                container.innerHTML = '<div class="no-records">No hay r√©cords todav√≠a</div>';
                return;
            }

            let html = '';
            records.forEach((record, index) => {
                let medalClass = '';
                let medal = '';
                if (index === 0) { medalClass = 'gold'; medal = 'ü•á'; }
                else if (index === 1) { medalClass = 'silver'; medal = 'ü•à'; }
                else if (index === 2) { medalClass = 'bronze'; medal = 'ü•â'; }
                else { medal = `#${index + 1}`; }

                html += `
                    <div class="record-item ${medalClass}">
                        <span class="record-rank">${medal}</span>
                        <span class="record-score">${record.score}</span>
                        <span class="record-date">Nv.${record.level || 1} - ${record.date}</span>
                    </div>
                `;
            });
            container.innerHTML = html;
        }

        // ===== GESTI√ìN DE MEN√öS =====
        function showMenu(menuId) {
            document.querySelectorAll('.menu-screen').forEach(menu => {
                menu.classList.add('hidden');
            });
            document.getElementById(menuId).classList.remove('hidden');
        }

        function hideAllMenus() {
            document.querySelectorAll('.menu-screen').forEach(menu => {
                menu.classList.add('hidden');
            });
        }

        function showGameUI() {
            document.getElementById('ui').classList.remove('hidden');
            document.getElementById('pauseBtn').classList.remove('hidden');
            document.getElementById('nanobotTimer').classList.remove('hidden');
            document.getElementById('swipeHint').classList.remove('hidden');
            document.getElementById('touchControls').classList.add('visible');
        }

        function hideGameUI() {
            document.getElementById('ui').classList.add('hidden');
            document.getElementById('pauseBtn').classList.add('hidden');
            document.getElementById('nanobotTimer').classList.add('hidden');
            document.getElementById('swipeHint').classList.add('hidden');
            document.getElementById('touchControls').classList.remove('visible');
        }

        function updateSpeedDisplay(value, displayId) {
            const setting = SPEED_SETTINGS[value];
            document.getElementById(displayId).textContent = setting.name;
        }

        function setGameSpeed(level) {
            currentSpeedLevel = level;
            const setting = SPEED_SETTINGS[level];
            CONFIG.SNAKE_SPEED = setting.speed;
            CONFIG.FAST_SPEED = setting.fast;
            baseSpeed = setting.speed;
            currentSpeed = baseSpeed;
            localStorage.setItem('cyberSnakeSpeed', level);
        }

        function loadSavedSpeed() {
            const saved = localStorage.getItem('cyberSnakeSpeed');
            if (saved) {
                currentSpeedLevel = parseInt(saved);
                setGameSpeed(currentSpeedLevel);
                document.getElementById('speedSlider').value = currentSpeedLevel;
                document.getElementById('pauseSpeedSlider').value = currentSpeedLevel;
                updateSpeedDisplay(currentSpeedLevel, 'speedValueDisplay');
                updateSpeedDisplay(currentSpeedLevel, 'pauseSpeedValueDisplay');
            }
        }

        // ===== THREE.JS SETUP =====
        function calculateGridSize() {
            const aspect = window.innerWidth / window.innerHeight;
            const baseSize = 7 + (level - 1) * 3;
            
            if (aspect < 1) {
                gridWidth = Math.round(baseSize * 0.85);
                gridHeight = Math.round(gridWidth / aspect * 0.82);
            } else {
                gridHeight = baseSize;
                gridWidth = Math.round(baseSize * aspect * 0.85);
            }
        }

        function initThree() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000510);

            const aspect = window.innerWidth / window.innerHeight;
            camera = new THREE.PerspectiveCamera(50, aspect, 0.1, 1000);
            camera.position.set(0, 25, 12);
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.getElementById('gameCanvas').appendChild(renderer.domElement);

            calculateGridSize();

            // Lighting
            const ambientLight = new THREE.AmbientLight(0x334466, 0.8);
            scene.add(ambientLight);

            const topLight = new THREE.DirectionalLight(0xffffff, 0.6);
            topLight.position.set(0, 50, 0);
            scene.add(topLight);

            const cyanLight = new THREE.PointLight(0x00ffff, 1, 100);
            cyanLight.position.set(-20, 20, -20);
            scene.add(cyanLight);

            const magentaLight = new THREE.PointLight(0xff00ff, 1, 100);
            magentaLight.position.set(20, 20, 20);
            scene.add(magentaLight);

            createBackground();
            window.addEventListener('resize', onWindowResize);
        }

        function updateCamera() {
            const aspect = window.innerWidth / window.innerHeight;
            const totalWidth = gridWidth * CONFIG.CELL_SIZE;
            const totalHeight = gridHeight * CONFIG.CELL_SIZE;
            
            camera.fov = 55;
            const fov = camera.fov * (Math.PI / 180);
            
            let cameraHeight, cameraZ, lookAtY, lookAtZ;
            
            if (aspect < 1) {
                const requiredHeightForWidth = (totalWidth / 2) / Math.tan(fov / 2) / aspect;
                cameraHeight = requiredHeightForWidth * 1.05;
                cameraZ = totalHeight * 0.5;
                lookAtY = 0;
                lookAtZ = -totalHeight * 0.05;
            } else {
                const requiredHeightForWidth = (totalWidth / 2) / Math.tan(fov / 2) / aspect;
                cameraHeight = requiredHeightForWidth * 1.1;
                cameraZ = totalHeight * 0.4;
                lookAtY = 0;
                lookAtZ = -totalHeight * 0.05;
            }
            
            camera.position.set(0, cameraHeight, cameraZ);
            camera.lookAt(0, lookAtY, lookAtZ);
            camera.aspect = aspect;
            camera.updateProjectionMatrix();
        }

        function createBackground() {
            const bgGeometry = new THREE.PlaneGeometry(500, 500);
            const bgMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    color1: { value: new THREE.Color(0x000520) },
                    color2: { value: new THREE.Color(0x0a0030) },
                    color3: { value: new THREE.Color(0x100040) }
                },
                vertexShader: `
                    varying vec2 vUv;
                    void main() {
                        vUv = uv;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float time;
                    uniform vec3 color1;
                    uniform vec3 color2;
                    uniform vec3 color3;
                    varying vec2 vUv;
                    
                    void main() {
                        vec2 p = vUv * 2.0 - 1.0;
                        float d = length(p);
                        
                        float wave1 = sin(p.x * 3.0 + time * 0.5) * cos(p.y * 3.0 + time * 0.3);
                        float wave2 = sin(p.x * 5.0 - time * 0.4) * sin(p.y * 4.0 + time * 0.6);
                        float wave3 = cos(d * 8.0 - time * 0.8) * 0.5;
                        
                        float pattern = (wave1 + wave2 + wave3) * 0.33 + 0.5;
                        
                        vec3 col = mix(color1, color2, pattern);
                        col = mix(col, color3, sin(d * 4.0 + time * 0.2) * 0.5 + 0.5);
                        col += vec3(0.0, 0.05, 0.1) * (1.0 - d * 0.5);
                        
                        gl_FragColor = vec4(col, 1.0);
                    }
                `
            });
            const bgPlane = new THREE.Mesh(bgGeometry, bgMaterial);
            bgPlane.rotation.x = -Math.PI / 2;
            bgPlane.position.y = -15;
            bgPlane.userData.isBackground = true;
            scene.add(bgPlane);

            // Stars
            for (let layer = 0; layer < 3; layer++) {
                const starsGeom = new THREE.BufferGeometry();
                const starsCount = 1500;
                const positions = new Float32Array(starsCount * 3);
                const colors = new Float32Array(starsCount * 3);

                for (let i = 0; i < starsCount; i++) {
                    positions[i * 3] = (Math.random() - 0.5) * 300;
                    positions[i * 3 + 1] = -3 - layer * 3 - Math.random() * 5;
                    positions[i * 3 + 2] = (Math.random() - 0.5) * 300;

                    const colorChoice = Math.random();
                    if (colorChoice < 0.25) {
                        colors[i * 3] = 0; colors[i * 3 + 1] = 1; colors[i * 3 + 2] = 1;
                    } else if (colorChoice < 0.5) {
                        colors[i * 3] = 1; colors[i * 3 + 1] = 0; colors[i * 3 + 2] = 1;
                    } else if (colorChoice < 0.75) {
                        colors[i * 3] = 0.5; colors[i * 3 + 1] = 0.5; colors[i * 3 + 2] = 1;
                    } else {
                        colors[i * 3] = 1; colors[i * 3 + 1] = 1; colors[i * 3 + 2] = 1;
                    }
                }

                starsGeom.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                starsGeom.setAttribute('color', new THREE.BufferAttribute(colors, 3));

                const starsMat = new THREE.PointsMaterial({
                    size: 0.2 + layer * 0.1,
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.9 - layer * 0.2
                });

                const stars = new THREE.Points(starsGeom, starsMat);
                stars.userData.rotSpeed = 0.0002 * (layer + 1);
                stars.userData.isStarLayer = true;
                scene.add(stars);
            }

            // Floating orbs
            for (let i = 0; i < 25; i++) {
                const orbGeom = new THREE.SphereGeometry(0.3 + Math.random() * 0.5, 16, 16);
                const hue = Math.random();
                const orbMat = new THREE.MeshBasicMaterial({
                    color: new THREE.Color().setHSL(hue, 1, 0.5),
                    transparent: true,
                    opacity: 0.3 + Math.random() * 0.3
                });
                const orb = new THREE.Mesh(orbGeom, orbMat);
                
                const radius = 20 + Math.random() * 40;
                const angle = Math.random() * Math.PI * 2;
                orb.position.set(Math.cos(angle) * radius, -2 - Math.random() * 3, Math.sin(angle) * radius);
                orb.userData = {
                    angle: angle,
                    radius: radius,
                    speed: 0.002 + Math.random() * 0.003,
                    ySpeed: 0.01 + Math.random() * 0.02,
                    baseY: orb.position.y,
                    isOrb: true
                };
                scene.add(orb);
                nebulaParticles.push(orb);
            }
        }

        function createGrid() {
            if (gridFloor) scene.remove(gridFloor);

            gridFloor = new THREE.Group();
            const totalWidth = gridWidth * CONFIG.CELL_SIZE;
            const totalHeight = gridHeight * CONFIG.CELL_SIZE;

            const floorGeom = new THREE.PlaneGeometry(totalWidth, totalHeight);
            const floorMat = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    gridSize: { value: new THREE.Vector2(gridWidth, gridHeight) }
                },
                vertexShader: `
                    varying vec2 vUv;
                    void main() {
                        vUv = uv;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float time;
                    uniform vec2 gridSize;
                    varying vec2 vUv;
                    
                    void main() {
                        vec2 grid = vUv * gridSize;
                        vec2 gridLines = abs(fract(grid - 0.5) - 0.5) / fwidth(grid);
                        float line = min(gridLines.x, gridLines.y);
                        
                        float dist = length(vUv - 0.5);
                        vec3 baseColor = mix(vec3(0.02, 0.04, 0.08), vec3(0.0, 0.01, 0.03), dist * 1.5);
                        
                        float pulse = sin(dist * 20.0 - time * 2.0) * 0.5 + 0.5;
                        pulse *= (1.0 - dist) * 0.3;
                        
                        float gridGlow = 1.0 - min(line, 1.0);
                        vec3 gridColor = mix(vec3(0.0, 0.8, 1.0), vec3(1.0, 0.0, 1.0), sin(time * 0.5 + dist * 3.0) * 0.5 + 0.5);
                        
                        vec3 finalColor = baseColor + gridColor * gridGlow * 0.4 + vec3(0.0, pulse * 0.3, pulse * 0.5);
                        
                        gl_FragColor = vec4(finalColor, 0.95);
                    }
                `,
                transparent: true
            });
            const floor = new THREE.Mesh(floorGeom, floorMat);
            floor.rotation.x = -Math.PI / 2;
            floor.position.y = -0.05;
            floor.userData.isFloor = true;
            gridFloor.add(floor);

            const edgeGeom = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(-totalWidth/2, 0.01, -totalHeight/2),
                new THREE.Vector3(totalWidth/2, 0.01, -totalHeight/2),
                new THREE.Vector3(totalWidth/2, 0.01, totalHeight/2),
                new THREE.Vector3(-totalWidth/2, 0.01, totalHeight/2),
                new THREE.Vector3(-totalWidth/2, 0.01, -totalHeight/2)
            ]);
            const edgeMat = new THREE.LineBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.8 });
            const edge = new THREE.Line(edgeGeom, edgeMat);
            edge.userData.isEdge = true;
            gridFloor.add(edge);

            const corners = [
                [-totalWidth/2, -totalHeight/2],
                [totalWidth/2, -totalHeight/2],
                [totalWidth/2, totalHeight/2],
                [-totalWidth/2, totalHeight/2]
            ];
            
            corners.forEach((pos, i) => {
                const markerGeom = new THREE.RingGeometry(0.3, 0.5, 4);
                const markerMat = new THREE.MeshBasicMaterial({
                    color: 0xff00ff,
                    transparent: true,
                    opacity: 0.7,
                    side: THREE.DoubleSide
                });
                const marker = new THREE.Mesh(markerGeom, markerMat);
                marker.rotation.x = -Math.PI / 2;
                marker.rotation.z = Math.PI / 4;
                marker.position.set(pos[0], 0.02, pos[1]);
                marker.userData.cornerIndex = i;
                gridFloor.add(marker);
            });

            scene.add(gridFloor);
        }

        function gridToWorld(gx, gz) {
            const totalWidth = gridWidth * CONFIG.CELL_SIZE;
            const totalHeight = gridHeight * CONFIG.CELL_SIZE;
            return {
                x: (gx + 0.5) * CONFIG.CELL_SIZE - totalWidth / 2,
                z: (gz + 0.5) * CONFIG.CELL_SIZE - totalHeight / 2
            };
        }

        function createSnakeSegment(gx, gz, index, totalLength) {
            const group = new THREE.Group();
            const isHead = index === 0;
            const colorIndex = Math.min(index, snakeColors.length - 1);
            const segmentColor = snakeColors[colorIndex];
            
            const sizeFactor = isHead ? 1 : Math.max(0.5, 1 - index * 0.03);
            const baseRadius = 0.35 * sizeFactor;

            if (isHead) {
                const headGroup = new THREE.Group();
                
                const headGeom = new THREE.SphereGeometry(0.38, 24, 18);
                headGeom.scale(0.9, 0.55, 1.3);
                const headMat = new THREE.MeshStandardMaterial({
                    color: 0x00ddaa, metalness: 0.4, roughness: 0.3,
                    emissive: 0x00ffcc, emissiveIntensity: 0.15
                });
                const headBase = new THREE.Mesh(headGeom, headMat);
                headBase.position.y = 0.22;
                headGroup.add(headBase);
                
                const snoutGeom = new THREE.ConeGeometry(0.22, 0.35, 16);
                snoutGeom.scale(0.8, 1, 1.2);
                const snoutMat = new THREE.MeshStandardMaterial({
                    color: 0x00eebb, metalness: 0.3, roughness: 0.4,
                    emissive: 0x00ffdd, emissiveIntensity: 0.1
                });
                const snout = new THREE.Mesh(snoutGeom, snoutMat);
                snout.rotation.x = Math.PI / 2;
                snout.position.set(0, 0.18, 0.42);
                headGroup.add(snout);
                
                // Eyes
                function createHypnoticEye(xPos) {
                    const eyeGroup = new THREE.Group();
                    
                    const eyeballGeom = new THREE.SphereGeometry(0.14, 32, 32);
                    const eyeballMat = new THREE.MeshStandardMaterial({
                        color: 0xffffaa, metalness: 0.1, roughness: 0.2,
                        emissive: 0xffff00, emissiveIntensity: 0.3
                    });
                    const eyeball = new THREE.Mesh(eyeballGeom, eyeballMat);
                    eyeGroup.add(eyeball);
                    
                    const spiralColors = [0xff00ff, 0x00ffff, 0xff00ff, 0x00ffff, 0xff00ff];
                    for (let i = 0; i < 5; i++) {
                        const ringRadius = 0.14 * (0.9 - i * 0.15);
                        const spiralGeom = new THREE.TorusGeometry(ringRadius, 0.012, 8, 32);
                        const spiralMat = new THREE.MeshBasicMaterial({
                            color: spiralColors[i], transparent: true, opacity: 0.9 - i * 0.1
                        });
                        const spiral = new THREE.Mesh(spiralGeom, spiralMat);
                        spiral.position.z = 0.01 + i * 0.008;
                        spiral.userData.spiralIndex = i;
                        spiral.userData.isSpiral = true;
                        eyeGroup.add(spiral);
                    }
                    
                    const pupilGeom = new THREE.CircleGeometry(0.035, 16);
                    const pupilMat = new THREE.MeshBasicMaterial({ color: 0x000000, side: THREE.DoubleSide });
                    const pupil = new THREE.Mesh(pupilGeom, pupilMat);
                    pupil.position.z = 0.06;
                    eyeGroup.add(pupil);
                    
                    eyeGroup.position.set(xPos, 0.32, 0.22);
                    eyeGroup.rotation.y = xPos > 0 ? 0.25 : -0.25;
                    eyeGroup.userData.isHypnoticEye = true;
                    
                    return eyeGroup;
                }
                
                headGroup.add(createHypnoticEye(0.2));
                headGroup.add(createHypnoticEye(-0.2));
                
                // Tongue
                const tongueGroup = new THREE.Group();
                const tongueBaseGeom = new THREE.CylinderGeometry(0.025, 0.02, 0.25, 8);
                const tongueMat = new THREE.MeshBasicMaterial({ color: 0xff3366, side: THREE.DoubleSide });
                const tongueBase = new THREE.Mesh(tongueBaseGeom, tongueMat);
                tongueBase.rotation.x = Math.PI / 2;
                tongueBase.position.z = 0.12;
                tongueGroup.add(tongueBase);
                
                const forkGeom = new THREE.ConeGeometry(0.018, 0.12, 6);
                const leftFork = new THREE.Mesh(forkGeom, tongueMat);
                leftFork.rotation.x = Math.PI / 2;
                leftFork.rotation.z = 0.4;
                leftFork.position.set(0.04, 0, 0.28);
                tongueGroup.add(leftFork);
                
                const rightFork = new THREE.Mesh(forkGeom, tongueMat);
                rightFork.rotation.x = Math.PI / 2;
                rightFork.rotation.z = -0.4;
                rightFork.position.set(-0.04, 0, 0.28);
                tongueGroup.add(rightFork);
                
                tongueGroup.position.set(0, 0.15, 0.45);
                tongueGroup.userData.isTongue = true;
                headGroup.add(tongueGroup);
                
                // Antenna
                const antennaGeom = new THREE.CylinderGeometry(0.015, 0.025, 0.18, 8);
                const antennaMat = new THREE.MeshBasicMaterial({ color: 0x00ffff });
                const antenna = new THREE.Mesh(antennaGeom, antennaMat);
                antenna.position.set(0, 0.48, -0.15);
                headGroup.add(antenna);
                
                const antennaTipGeom = new THREE.SphereGeometry(0.04, 8, 8);
                const antennaTipMat = new THREE.MeshBasicMaterial({ color: 0xff00ff, transparent: true, opacity: 0.9 });
                const antennaTip = new THREE.Mesh(antennaTipGeom, antennaTipMat);
                antennaTip.position.set(0, 0.58, -0.15);
                antennaTip.userData.isAntennaTip = true;
                headGroup.add(antennaTip);
                
                group.add(headGroup);

            } else {
                const bodyGeom = new THREE.SphereGeometry(baseRadius, 12, 10);
                bodyGeom.scale(1, 0.7, 1.1);
                
                const bodyMat = new THREE.MeshStandardMaterial({
                    color: segmentColor, metalness: 0.6, roughness: 0.3,
                    emissive: segmentColor, emissiveIntensity: 0.15
                });
                const body = new THREE.Mesh(bodyGeom, bodyMat);
                body.position.y = 0.2;
                group.add(body);

                const ringGeom = new THREE.TorusGeometry(baseRadius * 0.9, 0.02, 8, 16);
                const ringMat = new THREE.MeshBasicMaterial({
                    color: 0x00ffff, transparent: true, opacity: 0.5 - index * 0.02
                });
                const ring = new THREE.Mesh(ringGeom, ringMat);
                ring.rotation.x = Math.PI / 2;
                ring.position.y = 0.2;
                group.add(ring);
            }

            const worldPos = gridToWorld(gx, gz);
            group.position.set(worldPos.x, 0, worldPos.z);
            group.userData = { gridX: gx, gridZ: gz, index: index };

            scene.add(group);
            return group;
        }

        function createNanobot() {
            if (nanobot) scene.remove(nanobot);

            const group = new THREE.Group();

            const coreGeom = new THREE.IcosahedronGeometry(0.3, 1);
            const coreMat = new THREE.MeshStandardMaterial({
                color: 0xff00ff, metalness: 0.9, roughness: 0.1,
                emissive: 0xff00ff, emissiveIntensity: 0.8
            });
            const core = new THREE.Mesh(coreGeom, coreMat);
            group.add(core);

            for (let i = 0; i < 3; i++) {
                const ringGeom = new THREE.TorusGeometry(0.45 + i * 0.1, 0.02, 8, 32);
                const ringMat = new THREE.MeshBasicMaterial({
                    color: [0xff00ff, 0x00ffff, 0xffff00][i],
                    transparent: true, opacity: 0.8
                });
                const ring = new THREE.Mesh(ringGeom, ringMat);
                ring.rotation.x = Math.PI / 2 + i * 0.4;
                ring.rotation.z = i * 0.5;
                ring.userData.rotSpeed = 0.02 + i * 0.01;
                group.add(ring);
            }

            let gx, gz, valid, attempts = 0;
            do {
                gx = Math.floor(Math.random() * gridWidth);
                gz = Math.floor(Math.random() * gridHeight);
                valid = true;
                
                for (const seg of snake) {
                    if (seg.userData.gridX === gx && seg.userData.gridZ === gz) {
                        valid = false;
                        break;
                    }
                }
                for (const obs of obstacles) {
                    if (obs.userData.gridX === gx && obs.userData.gridZ === gz) {
                        valid = false;
                        break;
                    }
                }
                attempts++;
            } while (!valid && attempts < 100);

            const worldPos = gridToWorld(gx, gz);
            group.position.set(worldPos.x, 0.5, worldPos.z);
            group.userData = { gridX: gx, gridZ: gz };

            scene.add(group);
            nanobot = group;

            nanobotStartTime = Date.now();
            if (nanobotTimer) clearTimeout(nanobotTimer);
            nanobotTimer = setTimeout(() => {
                if (nanobot && gameRunning && !gamePaused) {
                    createExplosion(nanobot.position.x, nanobot.position.y, nanobot.position.z, 0xff00ff);
                    createNanobot();
                }
            }, CONFIG.NANOBOT_LIFETIME);
        }

        function createObstacle() {
            const group = new THREE.Group();

            const height = 1 + Math.random() * 1.5;
            const obstacleGeom = new THREE.OctahedronGeometry(0.35, 0);
            obstacleGeom.scale(1, height, 1);
            
            const obstacleMat = new THREE.MeshStandardMaterial({
                color: 0xff3300, metalness: 0.8, roughness: 0.2,
                emissive: 0xff2200, emissiveIntensity: 0.4
            });
            const obstacle = new THREE.Mesh(obstacleGeom, obstacleMat);
            obstacle.position.y = height * 0.35;
            group.add(obstacle);

            const ringGeom = new THREE.TorusGeometry(0.5, 0.05, 8, 32);
            const ringMat = new THREE.MeshBasicMaterial({
                color: 0xff0000, transparent: true, opacity: 0.6
            });
            const ring = new THREE.Mesh(ringGeom, ringMat);
            ring.rotation.x = Math.PI / 2;
            ring.position.y = 0.05;
            group.add(ring);

            let gx, gz, valid, attempts = 0;
            do {
                gx = Math.floor(Math.random() * gridWidth);
                gz = Math.floor(Math.random() * gridHeight);
                valid = true;
                
                if (snake.length > 0) {
                    const head = snake[0];
                    const dist = Math.abs(head.userData.gridX - gx) + Math.abs(head.userData.gridZ - gz);
                    if (dist < 5) valid = false;
                }
                
                for (const seg of snake) {
                    if (seg.userData.gridX === gx && seg.userData.gridZ === gz) {
                        valid = false;
                        break;
                    }
                }
                for (const obs of obstacles) {
                    if (obs.userData.gridX === gx && obs.userData.gridZ === gz) {
                        valid = false;
                        break;
                    }
                }
                if (nanobot && nanobot.userData.gridX === gx && nanobot.userData.gridZ === gz) {
                    valid = false;
                }
                attempts++;
            } while (!valid && attempts < 100);

            if (attempts >= 100) return;

            const worldPos = gridToWorld(gx, gz);
            group.position.set(worldPos.x, 0, worldPos.z);
            group.userData = { gridX: gx, gridZ: gz };

            scene.add(group);
            obstacles.push(group);
        }

        function createObstacleInBottomZone(oldHeight, deltaHeight) {
            if (deltaHeight <= 0) return;
            
            const group = new THREE.Group();

            const height = 1 + Math.random() * 1.5;
            const obstacleGeom = new THREE.OctahedronGeometry(0.35, 0);
            obstacleGeom.scale(1, height, 1);
            
            const obstacleMat = new THREE.MeshStandardMaterial({
                color: 0xff3300, metalness: 0.8, roughness: 0.2,
                emissive: 0xff2200, emissiveIntensity: 0.4
            });
            const obstacle = new THREE.Mesh(obstacleGeom, obstacleMat);
            obstacle.position.y = height * 0.35;
            group.add(obstacle);

            const ringGeom = new THREE.TorusGeometry(0.5, 0.05, 8, 32);
            const ringMat = new THREE.MeshBasicMaterial({
                color: 0xff0000, transparent: true, opacity: 0.6
            });
            const ring = new THREE.Mesh(ringGeom, ringMat);
            ring.rotation.x = Math.PI / 2;
            ring.position.y = 0.05;
            group.add(ring);

            let gx, gz, valid, attempts = 0;
            do {
                gx = Math.floor(Math.random() * gridWidth);
                gz = oldHeight + Math.floor(Math.random() * deltaHeight);
                valid = true;
                
                for (const seg of snake) {
                    if (seg.userData.gridX === gx && seg.userData.gridZ === gz) {
                        valid = false;
                        break;
                    }
                }
                for (const obs of obstacles) {
                    if (obs.userData.gridX === gx && obs.userData.gridZ === gz) {
                        valid = false;
                        break;
                    }
                }
                attempts++;
            } while (!valid && attempts < 100);

            if (attempts >= 100) return;

            const worldPos = gridToWorld(gx, gz);
            group.position.set(worldPos.x, 0, worldPos.z);
            group.userData = { gridX: gx, gridZ: gz };

            scene.add(group);
            obstacles.push(group);
        }

        function createObstacleAt(gx, gz) {
            const group = new THREE.Group();

            const height = 1 + Math.random() * 1.5;
            const obstacleGeom = new THREE.OctahedronGeometry(0.35, 0);
            obstacleGeom.scale(1, height, 1);
            
            const obstacleMat = new THREE.MeshStandardMaterial({
                color: 0xff3300, metalness: 0.8, roughness: 0.2,
                emissive: 0xff2200, emissiveIntensity: 0.4
            });
            const obstacle = new THREE.Mesh(obstacleGeom, obstacleMat);
            obstacle.position.y = height * 0.35;
            group.add(obstacle);

            const ringGeom = new THREE.TorusGeometry(0.5, 0.05, 8, 32);
            const ringMat = new THREE.MeshBasicMaterial({
                color: 0xff0000, transparent: true, opacity: 0.6
            });
            const ring = new THREE.Mesh(ringGeom, ringMat);
            ring.rotation.x = Math.PI / 2;
            ring.position.y = 0.05;
            group.add(ring);

            const worldPos = gridToWorld(gx, gz);
            group.position.set(worldPos.x, 0, worldPos.z);
            group.userData = { gridX: gx, gridZ: gz };

            scene.add(group);
            return group;
        }

        function createExplosion(x, y, z, color) {
            for (let i = 0; i < 25; i++) {
                const geom = new THREE.SphereGeometry(0.08, 6, 6);
                const mat = new THREE.MeshBasicMaterial({
                    color: new THREE.Color(color), transparent: true, opacity: 1
                });
                const particle = new THREE.Mesh(geom, mat);
                particle.position.set(x, y, z);
                
                const speed = 0.15 + Math.random() * 0.2;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI;
                
                particle.userData = {
                    velocity: new THREE.Vector3(
                        Math.sin(phi) * Math.cos(theta) * speed,
                        Math.cos(phi) * speed * 0.5 + 0.1,
                        Math.sin(phi) * Math.sin(theta) * speed
                    ),
                    life: 1,
                    decay: 0.02 + Math.random() * 0.01
                };
                
                scene.add(particle);
                particles.push(particle);
            }
        }

        function initGame() {
            snake.forEach(s => scene.remove(s));
            snake = [];
            obstacles.forEach(o => scene.remove(o));
            obstacles = [];
            particles.forEach(p => scene.remove(p));
            particles = [];
            if (nanobot) scene.remove(nanobot);
            nanobot = null;
            if (nanobotTimer) clearTimeout(nanobotTimer);

            score = 0;
            level = 1;
            direction = { x: 1, y: 0 };
            nextDirection = { x: 1, y: 0 };
            currentSpeed = baseSpeed;
            gamePaused = false;

            calculateGridSize();
            createGrid();
            updateCamera();
            updateUI();

            const startX = Math.floor(gridWidth / 2);
            const startZ = Math.floor(gridHeight / 2);

            snake.push(createSnakeSegment(startX, startZ, 0, 3));
            snake.push(createSnakeSegment(startX - 1, startZ, 1, 3));
            snake.push(createSnakeSegment(startX - 2, startZ, 2, 3));

            snake[0].rotation.y = Math.PI / 2;

            createNanobot();
            gameRunning = true;
            lastMoveTime = Date.now();
            
            hideAllMenus();
            showGameUI();
        }

        function updateSnake() {
            if (gamePaused) return;
            
            const now = Date.now();
            if (now - lastMoveTime < currentSpeed) return;
            lastMoveTime = now;

            direction = { ...nextDirection };

            const head = snake[0];
            let newX = head.userData.gridX + direction.x;
            let newZ = head.userData.gridZ + direction.y;

            if (newX < 0) newX = gridWidth - 1;
            if (newX >= gridWidth) newX = 0;
            if (newZ < 0) newZ = gridHeight - 1;
            if (newZ >= gridHeight) newZ = 0;

            for (let i = 1; i < snake.length; i++) {
                if (snake[i].userData.gridX === newX && snake[i].userData.gridZ === newZ) {
                    gameOver();
                    return;
                }
            }

            for (const obs of obstacles) {
                if (obs.userData.gridX === newX && obs.userData.gridZ === newZ) {
                    gameOver();
                    return;
                }
            }

            let grow = false;
            if (nanobot && nanobot.userData.gridX === newX && nanobot.userData.gridZ === newZ) {
                grow = true;
                score++;
                
                createExplosion(nanobot.position.x, nanobot.position.y, nanobot.position.z, 0xff00ff);
                scene.remove(nanobot);
                nanobot = null;
                clearTimeout(nanobotTimer);

                if (score % CONFIG.GROWTH_THRESHOLD === 0) {
                    levelUp();
                } else {
                    createNanobot();
                }

                updateUI();
            }

            const positions = [{ x: newX, z: newZ }];
            snake.forEach(seg => {
                positions.push({ x: seg.userData.gridX, z: seg.userData.gridZ });
            });

            snake.forEach(seg => scene.remove(seg));
            snake = [];

            const newLength = grow ? positions.length : positions.length - 1;
            for (let i = 0; i < newLength; i++) {
                snake.push(createSnakeSegment(positions[i].x, positions[i].z, i, newLength));
            }

            if (direction.x === 1) snake[0].rotation.y = Math.PI / 2;
            else if (direction.x === -1) snake[0].rotation.y = -Math.PI / 2;
            else if (direction.y === -1) snake[0].rotation.y = Math.PI;
            else if (direction.y === 1) snake[0].rotation.y = 0;

            document.getElementById('length').textContent = snake.length;
        }

        function levelUp() {
            level++;
            
            const levelUpEl = document.getElementById('levelUp');
            levelUpEl.textContent = `¬°NIVEL ${level}!`;
            levelUpEl.classList.add('active');
            setTimeout(() => levelUpEl.classList.remove('active'), 1500);

            const snakeGridPositions = snake.map(seg => ({
                gx: seg.userData.gridX,
                gz: seg.userData.gridZ
            }));
            
            const oldGridWidth = gridWidth;
            const oldGridHeight = gridHeight;

            calculateGridSize();
            
            const deltaWidth = gridWidth - oldGridWidth;
            const deltaHeight = gridHeight - oldGridHeight;
            
            const offsetX = Math.floor(deltaWidth / 2);
            const offsetZ = 0;
            
            createGrid();
            updateCamera();

            snake.forEach(seg => scene.remove(seg));
            snake = [];
            
            snakeGridPositions.forEach((pos, i) => {
                const newX = pos.gx + offsetX;
                const newZ = pos.gz;
                snake.push(createSnakeSegment(newX, newZ, i, snakeGridPositions.length));
            });

            if (direction.x === 1) snake[0].rotation.y = Math.PI / 2;
            else if (direction.x === -1) snake[0].rotation.y = -Math.PI / 2;
            else if (direction.y === -1) snake[0].rotation.y = Math.PI;
            else if (direction.y === 1) snake[0].rotation.y = 0;

            const obstacleGridPositions = obstacles.map(obs => ({
                gx: obs.userData.gridX,
                gz: obs.userData.gridZ
            }));
            
            obstacles.forEach(obs => scene.remove(obs));
            obstacles = [];
            
            obstacleGridPositions.forEach(pos => {
                const newGx = pos.gx + offsetX;
                const newGz = pos.gz;
                
                const group = createObstacleAt(newGx, newGz);
                if (group) obstacles.push(group);
            });

            for (let i = 0; i < CONFIG.OBSTACLE_PER_LEVEL; i++) {
                createObstacleInBottomZone(oldGridHeight, deltaHeight);
            }

            createNanobot();
            document.getElementById('level').textContent = level;
        }

        function gameOver() {
            gameRunning = false;
            
            snake.forEach(seg => {
                createExplosion(seg.position.x, seg.position.y + 0.3, seg.position.z, 0x00ffff);
            });

            const isNewRecord = saveRecord(score);
            
            document.getElementById('finalScore').textContent = score;
            document.getElementById('newRecordText').classList.toggle('hidden', !isNewRecord);
            
            setTimeout(() => {
                hideGameUI();
                showMenu('gameOverScreen');
            }, 500);
        }

        function pauseGame() {
            if (!gameRunning) return;
            gamePaused = true;
            document.getElementById('pauseSpeedSlider').value = currentSpeedLevel;
            updateSpeedDisplay(currentSpeedLevel, 'pauseSpeedValueDisplay');
            showMenu('pauseMenu');
        }

        function resumeGame() {
            gamePaused = false;
            hideAllMenus();
            lastMoveTime = Date.now();
        }

        function updateUI() {
            document.getElementById('score').textContent = score;
            document.getElementById('length').textContent = snake.length;
            document.getElementById('level').textContent = level;
        }

        function updateTimerDisplay() {
            if (!nanobot || !gameRunning || gamePaused) return;
            
            const elapsed = Date.now() - nanobotStartTime;
            const remaining = Math.max(0, CONFIG.NANOBOT_LIFETIME - elapsed);
            const percent = (remaining / CONFIG.NANOBOT_LIFETIME) * 100;
            
            document.getElementById('timerFill').style.width = percent + '%';
        }

        function animate() {
            requestAnimationFrame(animate);

            const time = Date.now() * 0.001;

            if (gameRunning && !gamePaused) {
                updateSnake();
                updateTimerDisplay();
            }

            // Animate background
            scene.children.forEach(child => {
                if (child.userData.isBackground && child.material.uniforms) {
                    child.material.uniforms.time.value = time;
                }
                if (child.userData.isStarLayer) {
                    child.rotation.y += child.userData.rotSpeed;
                }
            });

            // Animate orbs
            nebulaParticles.forEach((orb, i) => {
                const data = orb.userData;
                if (data.isOrb) {
                    data.angle += data.speed;
                    orb.position.x = Math.cos(data.angle) * data.radius;
                    orb.position.z = Math.sin(data.angle) * data.radius;
                    orb.position.y = data.baseY + Math.sin(time * data.ySpeed * 50 + i) * 1.5;
                    orb.material.opacity = 0.3 + Math.sin(time * 2 + i) * 0.2;
                }
            });

            // Animate nanobot
            if (nanobot) {
                nanobot.rotation.y += 0.03;
                nanobot.position.y = 0.5 + Math.sin(time * 4) * 0.15;
                nanobot.children.forEach(child => {
                    if (child.userData.rotSpeed) {
                        child.rotation.z += child.userData.rotSpeed;
                    }
                });
            }

            // Animate obstacles
            obstacles.forEach((obs, i) => {
                if (obs.children[0]) obs.children[0].rotation.y += 0.01;
                if (obs.children[1]) {
                    const pulse = 1 + Math.sin(time * 3 + i) * 0.1;
                    obs.children[1].scale.setScalar(pulse);
                }
            });

            // Animate snake
            if (snake.length > 0) {
                const headGroup = snake[0].children[0];
                if (headGroup && headGroup.children) {
                    headGroup.children.forEach(child => {
                        if (child.userData && child.userData.isTongue) {
                            child.position.z = 0.45 + Math.sin(time * 12) * 0.15;
                            child.rotation.y = Math.sin(time * 8) * 0.1;
                        }
                        
                        if (child.userData && child.userData.isHypnoticEye) {
                            child.children.forEach(eyePart => {
                                if (eyePart.userData && eyePart.userData.isSpiral) {
                                    const dir = eyePart.userData.spiralIndex % 2 === 0 ? 1 : -1;
                                    eyePart.rotation.z = time * 3 * dir + eyePart.userData.spiralIndex * 0.5;
                                    const pulse = 1 + Math.sin(time * 4 + eyePart.userData.spiralIndex) * 0.1;
                                    eyePart.scale.setScalar(pulse);
                                }
                            });
                        }
                        
                        if (child.userData && child.userData.isAntennaTip) {
                            child.material.opacity = 0.5 + Math.sin(time * 6) * 0.4;
                            const glowScale = 1 + Math.sin(time * 8) * 0.3;
                            child.scale.setScalar(glowScale);
                        }
                    });
                }

                snake.forEach((seg, i) => {
                    if (i > 0) {
                        seg.position.y = Math.sin(time * 5 + i * 0.4) * 0.05;
                    }
                });
            }

            // Animate floor
            if (gridFloor) {
                gridFloor.children.forEach(child => {
                    if (child.userData.isFloor && child.material.uniforms) {
                        child.material.uniforms.time.value = time;
                    }
                    if (child.userData.isEdge) {
                        child.material.opacity = 0.5 + Math.sin(time * 3) * 0.3;
                    }
                    if (child.userData.cornerIndex !== undefined) {
                        child.rotation.z = Math.PI / 4 + time * 0.5 + child.userData.cornerIndex * 0.5;
                        child.scale.setScalar(1 + Math.sin(time * 2 + child.userData.cornerIndex) * 0.2);
                    }
                });
            }

            // Update particles
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.position.add(p.userData.velocity);
                p.userData.velocity.y -= 0.005;
                p.userData.life -= p.userData.decay;
                p.material.opacity = p.userData.life;

                if (p.userData.life <= 0) {
                    scene.remove(p);
                    particles.splice(i, 1);
                }
            }

            renderer.render(scene, camera);
        }

        function onWindowResize() {
            const aspect = window.innerWidth / window.innerHeight;
            renderer.setSize(window.innerWidth, window.innerHeight);
            
            if (gridWidth && gridHeight) {
                updateCamera();
            }
        }

        // ===== EVENT LISTENERS =====
        
        // Keyboard
        document.addEventListener('keydown', (e) => {
            if (!gameRunning || gamePaused) return;

            switch (e.key.toLowerCase()) {
                case 'arrowup': case 'w':
                    if (direction.y !== 1) nextDirection = { x: 0, y: -1 };
                    break;
                case 'arrowdown': case 's':
                    if (direction.y !== -1) nextDirection = { x: 0, y: 1 };
                    break;
                case 'arrowleft': case 'a':
                    if (direction.x !== 1) nextDirection = { x: -1, y: 0 };
                    break;
                case 'arrowright': case 'd':
                    if (direction.x !== -1) nextDirection = { x: 1, y: 0 };
                    break;
                case ' ':
                    currentSpeed = CONFIG.FAST_SPEED;
                    break;
                case 'escape': case 'p':
                    pauseGame();
                    break;
            }
        });

        document.addEventListener('keyup', (e) => {
            if (e.key === ' ') {
                currentSpeed = baseSpeed;
            }
        });

        // Touch/Swipe
        document.addEventListener('touchstart', (e) => {
            touchStartX = e.touches[0].clientX;
            touchStartY = e.touches[0].clientY;
        }, { passive: false });

        document.addEventListener('touchmove', (e) => {
            e.preventDefault();
        }, { passive: false });

        document.addEventListener('touchend', (e) => {
            if (!gameRunning || gamePaused) return;

            const touchEndX = e.changedTouches[0].clientX;
            const touchEndY = e.changedTouches[0].clientY;
            
            const deltaX = touchEndX - touchStartX;
            const deltaY = touchEndY - touchStartY;
            
            if (Math.abs(deltaX) < touchThreshold && Math.abs(deltaY) < touchThreshold) {
                return;
            }

            if (Math.abs(deltaX) > Math.abs(deltaY)) {
                if (deltaX > 0 && direction.x !== -1) {
                    nextDirection = { x: 1, y: 0 };
                } else if (deltaX < 0 && direction.x !== 1) {
                    nextDirection = { x: -1, y: 0 };
                }
            } else {
                if (deltaY > 0 && direction.y !== -1) {
                    nextDirection = { x: 0, y: 1 };
                } else if (deltaY < 0 && direction.y !== 1) {
                    nextDirection = { x: 0, y: -1 };
                }
            }
        }, { passive: false });

        // ===== MENU BUTTONS =====
        
        // Main Menu
        document.getElementById('btnPlay').addEventListener('click', initGame);
        
        document.getElementById('btnSpeed').addEventListener('click', () => {
            showMenu('speedMenu');
        });
        
        document.getElementById('btnRecords').addEventListener('click', () => {
            updateRecordsList();
            showMenu('recordsMenu');
        });
        
        document.getElementById('btnExit').addEventListener('click', () => {
            if (confirm('¬øSeguro que quieres salir?')) {
                window.close();
                // Fallback if window.close doesn't work
                document.body.innerHTML = '<div style="display:flex;justify-content:center;align-items:center;height:100vh;color:#0ff;font-family:Orbitron,sans-serif;font-size:24px;background:#000;">¬°Gracias por jugar!</div>';
            }
        });

        // Speed Menu
        document.getElementById('speedSlider').addEventListener('input', (e) => {
            const val = parseInt(e.target.value);
            updateSpeedDisplay(val, 'speedValueDisplay');
            setGameSpeed(val);
        });

        document.getElementById('btnSpeedBack').addEventListener('click', () => {
            showMenu('mainMenu');
        });

        // Records Menu
        document.getElementById('btnClearRecords').addEventListener('click', () => {
            if (confirm('¬øSeguro que quieres borrar todos los r√©cords?')) {
                clearRecords();
            }
        });

        document.getElementById('btnRecordsBack').addEventListener('click', () => {
            showMenu('mainMenu');
        });

        // Pause Menu
        document.getElementById('pauseBtn').addEventListener('click', pauseGame);

        document.getElementById('pauseSpeedSlider').addEventListener('input', (e) => {
            const val = parseInt(e.target.value);
            updateSpeedDisplay(val, 'pauseSpeedValueDisplay');
            setGameSpeed(val);
        });

        document.getElementById('btnResume').addEventListener('click', resumeGame);

        document.getElementById('btnRestartPause').addEventListener('click', () => {
            hideAllMenus();
            initGame();
        });

        document.getElementById('btnExitToMenu').addEventListener('click', () => {
            gameRunning = false;
            gamePaused = false;
            hideGameUI();
            showMenu('mainMenu');
        });

        // Game Over
        document.getElementById('btnRestart').addEventListener('click', initGame);

        document.getElementById('btnGameOverMenu').addEventListener('click', () => {
            showMenu('mainMenu');
        });

        // D-Pad controls
        const dpadButtons = {
            btnUp: { x: 0, y: -1 },
            btnDown: { x: 0, y: 1 },
            btnLeft: { x: -1, y: 0 },
            btnRight: { x: 1, y: 0 }
        };

        Object.entries(dpadButtons).forEach(([id, dir]) => {
            const btn = document.getElementById(id);
            
            btn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                if (!gameRunning || gamePaused) return;
                btn.classList.add('active');
                
                if (dir.x !== 0 && direction.x !== -dir.x) {
                    nextDirection = { ...dir };
                } else if (dir.y !== 0 && direction.y !== -dir.y) {
                    nextDirection = { ...dir };
                }
            }, { passive: false });

            btn.addEventListener('touchend', (e) => {
                e.preventDefault();
                btn.classList.remove('active');
            }, { passive: false });

            btn.addEventListener('mousedown', (e) => {
                if (!gameRunning || gamePaused) return;
                btn.classList.add('active');
                
                if (dir.x !== 0 && direction.x !== -dir.x) {
                    nextDirection = { ...dir };
                } else if (dir.y !== 0 && direction.y !== -dir.y) {
                    nextDirection = { ...dir };
                }
            });

            btn.addEventListener('mouseup', () => btn.classList.remove('active'));
            btn.addEventListener('mouseleave', () => btn.classList.remove('active'));
        });

        // Turbo button
        const turboBtn = document.getElementById('turboBtn');
        
        turboBtn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            turboBtn.classList.add('active');
            currentSpeed = CONFIG.FAST_SPEED;
        }, { passive: false });

        turboBtn.addEventListener('touchend', (e) => {
            e.preventDefault();
            turboBtn.classList.remove('active');
            currentSpeed = baseSpeed;
        }, { passive: false });

        turboBtn.addEventListener('touchcancel', () => {
            turboBtn.classList.remove('active');
            currentSpeed = baseSpeed;
        }, { passive: false });

        turboBtn.addEventListener('mousedown', () => {
            turboBtn.classList.add('active');
            currentSpeed = CONFIG.FAST_SPEED;
        });

        turboBtn.addEventListener('mouseup', () => {
            turboBtn.classList.remove('active');
            currentSpeed = baseSpeed;
        });

        turboBtn.addEventListener('mouseleave', () => {
            turboBtn.classList.remove('active');
            currentSpeed = baseSpeed;
        });

        // ===== INITIALIZATION =====
        initThree();
        calculateGridSize();
        updateCamera();
        loadSavedSpeed();
        updateRecordsList();
        animate();
    </script>
</body>
</html>
