<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>CYBER SNAKE - Nanobot Hunter</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            touch-action: none;
        }

        body {
            overflow: hidden;
            background: #000;
            font-family: 'Orbitron', 'Segoe UI', sans-serif;
            position: fixed;
            width: 100%;
            height: 100%;
        }

        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');

        #gameCanvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        #ui {
            position: fixed;
            top: 10px;
            left: 10px;
            right: 10px;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            pointer-events: none;
            z-index: 100;
        }

        .hud-panel {
            background: linear-gradient(135deg, rgba(0, 255, 255, 0.04), rgba(0, 100, 150, 0.06));
            border: 1px solid rgba(0, 255, 255, 0.12);
            border-radius: 5px;
            padding: 3px 6px;
            backdrop-filter: blur(3px);
        }

        .score-display {
            color: rgba(0, 255, 255, 0.9);
            font-size: 14px;
            font-weight: 700;
            text-shadow: 0 0 8px rgba(0, 255, 255, 0.5);
            font-family: 'Orbitron', monospace;
        }

        .score-label {
            color: rgba(0, 255, 255, 0.5);
            font-size: 7px;
            letter-spacing: 1px;
            margin-bottom: 1px;
        }

        .level-display {
            color: rgba(255, 0, 255, 0.9);
            font-size: 14px;
            font-weight: 700;
            text-shadow: 0 0 8px rgba(255, 0, 255, 0.5);
        }

        .length-display {
            color: rgba(0, 255, 0, 0.9);
            font-size: 12px;
            font-weight: 700;
            text-shadow: 0 0 8px rgba(0, 255, 0, 0.5);
        }

        .nanobot-timer {
            position: fixed;
            top: 48px;
            right: 10px;
            background: linear-gradient(135deg, rgba(255, 0, 100, 0.05), rgba(150, 0, 100, 0.08));
            border: 1px solid rgba(255, 0, 150, 0.15);
            border-radius: 8px;
            padding: 2px 8px;
            color: rgba(255, 0, 255, 0.6);
            font-family: 'Orbitron', monospace;
            font-size: 7px;
            backdrop-filter: blur(3px);
            pointer-events: none;
        }

        .timer-bar {
            width: 50px;
            height: 3px;
            background: rgba(255, 255, 255, 0.15);
            border-radius: 2px;
            margin-top: 3px;
            overflow: hidden;
        }

        .timer-fill {
            height: 100%;
            background: linear-gradient(90deg, #f0f, #0ff);
            border-radius: 2px;
            transition: width 0.1s linear;
        }

        #startScreen, #gameOverScreen {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: radial-gradient(ellipse at center, rgba(0, 50, 80, 0.95), rgba(0, 10, 20, 0.98));
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 200;
            padding: 20px;
        }

        #gameOverScreen {
            display: none;
        }

        .title {
            font-family: 'Orbitron', sans-serif;
            font-size: clamp(28px, 8vw, 72px);
            font-weight: 900;
            background: linear-gradient(180deg, #0ff, #f0f);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            filter: drop-shadow(0 0 20px rgba(0, 255, 255, 0.8));
            margin-bottom: 10px;
            text-align: center;
            animation: titlePulse 2s ease-in-out infinite;
        }

        @keyframes titlePulse {
            0%, 100% { filter: drop-shadow(0 0 20px rgba(0, 255, 255, 0.8)); }
            50% { filter: drop-shadow(0 0 40px rgba(255, 0, 255, 0.9)); }
        }

        .subtitle {
            color: rgba(0, 255, 255, 0.8);
            font-size: clamp(12px, 3vw, 24px);
            letter-spacing: 5px;
            margin-bottom: 40px;
            font-family: 'Orbitron', sans-serif;
            text-align: center;
        }

        .start-btn {
            background: linear-gradient(135deg, rgba(0, 255, 255, 0.2), rgba(255, 0, 255, 0.2));
            border: 2px solid #0ff;
            color: #0ff;
            padding: 15px 40px;
            font-size: clamp(14px, 4vw, 24px);
            font-family: 'Orbitron', sans-serif;
            font-weight: 700;
            cursor: pointer;
            border-radius: 30px;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 3px;
        }

        .start-btn:hover, .start-btn:active {
            background: linear-gradient(135deg, rgba(0, 255, 255, 0.4), rgba(255, 0, 255, 0.4));
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.6);
            transform: scale(1.05);
        }

        .controls-info {
            margin-top: 30px;
            color: rgba(255, 255, 255, 0.6);
            font-size: clamp(10px, 2.5vw, 14px);
            text-align: center;
            line-height: 2;
        }

        .controls-info span {
            color: #0ff;
            font-weight: bold;
        }

        .final-score {
            font-size: clamp(24px, 6vw, 48px);
            color: #f0f;
            font-family: 'Orbitron', sans-serif;
            margin: 20px 0;
            text-shadow: 0 0 20px #f0f;
        }

        .scanlines {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            background: repeating-linear-gradient(
                0deg,
                rgba(0, 0, 0, 0.03) 0px,
                rgba(0, 0, 0, 0.03) 1px,
                transparent 1px,
                transparent 3px
            );
            z-index: 300;
        }

        .level-up {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #0ff;
            font-size: clamp(24px, 6vw, 48px);
            font-family: 'Orbitron', sans-serif;
            font-weight: 900;
            text-shadow: 0 0 30px #0ff, 0 0 60px #f0f;
            opacity: 0;
            pointer-events: none;
            z-index: 250;
        }

        .level-up.active {
            animation: levelUpAnim 1.5s ease-out forwards;
        }

        @keyframes levelUpAnim {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
            20% { opacity: 1; transform: translate(-50%, -50%) scale(1.2); }
            80% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(1.5); }
        }

        .swipe-hint {
            position: fixed;
            bottom: 140px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255, 255, 255, 0.3);
            font-size: 9px;
            font-family: 'Orbitron', sans-serif;
            letter-spacing: 2px;
            pointer-events: none;
        }

        /* Controles t√°ctiles */
        .touch-controls {
            position: fixed;
            bottom: 20px;
            left: 20px;
            right: 20px;
            display: flex;
            justify-content: space-between;
            align-items: flex-end;
            pointer-events: none;
            z-index: 150;
        }

        /* D-Pad (Flechas direccionales) */
        .dpad {
            position: relative;
            width: 140px;
            height: 140px;
            pointer-events: auto;
        }

        .dpad-btn {
            position: absolute;
            width: 44px;
            height: 44px;
            background: linear-gradient(145deg, rgba(0, 255, 255, 0.06), rgba(0, 150, 200, 0.1));
            border: 1px solid rgba(0, 255, 255, 0.15);
            border-radius: 10px;
            display: flex;
            justify-content: center;
            align-items: center;
            color: rgba(0, 255, 255, 0.4);
            font-size: 18px;
            cursor: pointer;
            transition: all 0.15s ease;
            backdrop-filter: blur(2px);
            box-shadow: 0 0 8px rgba(0, 255, 255, 0.08);
        }

        .dpad-btn:active, .dpad-btn.active {
            background: linear-gradient(145deg, rgba(0, 255, 255, 0.2), rgba(0, 200, 255, 0.25));
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.25);
            transform: scale(0.95);
            color: rgba(0, 255, 255, 0.7);
        }

        .dpad-up {
            top: 0;
            left: 50%;
            transform: translateX(-50%);
        }

        .dpad-down {
            bottom: 0;
            left: 50%;
            transform: translateX(-50%);
        }

        .dpad-left {
            left: 0;
            top: 50%;
            transform: translateY(-50%);
        }

        .dpad-right {
            right: 0;
            top: 50%;
            transform: translateY(-50%);
        }

        /* Bot√≥n Turbo con forma de huevo */
        .turbo-container {
            pointer-events: auto;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .turbo-btn {
            width: 65px;
            height: 80px;
            background: linear-gradient(180deg, 
                rgba(255, 100, 0, 0.08) 0%,
                rgba(255, 50, 100, 0.12) 40%,
                rgba(255, 0, 150, 0.15) 70%,
                rgba(200, 0, 100, 0.18) 100%
            );
            border: 1px solid rgba(255, 100, 50, 0.2);
            border-radius: 50% 50% 50% 50% / 60% 60% 40% 40%;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            transition: all 0.15s ease;
            box-shadow: 
                0 0 10px rgba(255, 100, 0, 0.1),
                inset 0 -8px 15px rgba(0, 0, 0, 0.1),
                inset 0 8px 15px rgba(255, 255, 255, 0.03);
            position: relative;
            overflow: hidden;
        }

        .turbo-btn::before {
            content: '';
            position: absolute;
            top: 10%;
            left: 20%;
            width: 25%;
            height: 20%;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            filter: blur(3px);
        }

        .turbo-btn:active, .turbo-btn.active {
            background: linear-gradient(180deg, 
                rgba(255, 200, 0, 0.25) 0%,
                rgba(255, 100, 50, 0.3) 40%,
                rgba(255, 50, 150, 0.35) 70%,
                rgba(255, 0, 100, 0.4) 100%
            );
            border-color: rgba(255, 255, 0, 0.4);
            transform: scale(0.95);
            box-shadow: 
                0 0 20px rgba(255, 200, 0, 0.25),
                inset 0 -8px 15px rgba(0, 0, 0, 0.15),
                inset 0 8px 15px rgba(255, 255, 255, 0.08);
        }

        .turbo-icon {
            font-size: 22px;
            color: rgba(255, 255, 255, 0.5);
            text-shadow: 0 0 8px rgba(255, 255, 0, 0.3);
            margin-bottom: 2px;
        }

        .turbo-text {
            color: rgba(255, 255, 255, 0.4);
            font-family: 'Orbitron', sans-serif;
            font-size: 8px;
            font-weight: 700;
            letter-spacing: 1px;
        }

        .turbo-label {
            color: rgba(255, 150, 50, 0.3);
            font-family: 'Orbitron', sans-serif;
            font-size: 7px;
            margin-top: 4px;
            letter-spacing: 1px;
        }
        
        .dpad-center {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 30px;
            height: 30px;
            background: rgba(0, 255, 255, 0.08);
            border: 1px solid rgba(0, 255, 255, 0.15);
            border-radius: 50%;
        }
    </style>
</head>
<body>
    <div id="gameCanvas"></div>
    
    <div class="scanlines"></div>
    
    <div id="ui">
        <div class="hud-panel">
            <div class="score-label">NANOBOTS</div>
            <div class="score-display" id="score">0</div>
        </div>
        <div class="hud-panel" style="text-align: center;">
            <div class="score-label">NIVEL</div>
            <div class="level-display" id="level">1</div>
        </div>
        <div class="hud-panel">
            <div class="score-label">LONGITUD</div>
            <div class="length-display" id="length">3</div>
        </div>
    </div>

    <div class="nanobot-timer">
        <div>NANOBOT</div>
        <div class="timer-bar">
            <div class="timer-fill" id="timerFill"></div>
        </div>
    </div>

    <div class="level-up" id="levelUp">¬°NIVEL COMPLETADO!</div>
    <div class="swipe-hint">DESLIZA O USA LAS FLECHAS</div>

    <!-- Controles t√°ctiles -->
    <div class="touch-controls" id="touchControls">
        <!-- D-Pad izquierdo -->
        <div class="dpad">
            <div class="dpad-center"></div>
            <button class="dpad-btn dpad-up" id="btnUp">‚ñ≤</button>
            <button class="dpad-btn dpad-down" id="btnDown">‚ñº</button>
            <button class="dpad-btn dpad-left" id="btnLeft">‚óÄ</button>
            <button class="dpad-btn dpad-right" id="btnRight">‚ñ∂</button>
        </div>

        <!-- Bot√≥n Turbo (huevo) derecho -->
        <div class="turbo-container">
            <button class="turbo-btn" id="turboBtn">
                <span class="turbo-icon">‚ö°</span>
                <span class="turbo-text">TURBO</span>
            </button>
            <span class="turbo-label">MANTENER</span>
        </div>
    </div>

    <div id="startScreen">
        <div class="title">CYBER SNAKE</div>
        <div class="subtitle">NANOBOT HUNTER</div>
        <button class="start-btn" id="startBtn">INICIAR</button>
        <div class="controls-info">
            <span>‚Üë ‚Üì ‚Üê ‚Üí</span> o <span>W A S D</span> para mover<br>
            <span>DESLIZA</span> o usa el <span>D-PAD</span> t√°ctil<br>
            <span>ü•ö TURBO</span> para velocidad x3
        </div>
    </div>

    <div id="gameOverScreen">
        <div class="title" style="font-size: clamp(24px, 6vw, 48px);">GAME OVER</div>
        <div class="final-score">SCORE: <span id="finalScore">0</span></div>
        <button class="start-btn" id="restartBtn">REINICIAR</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Game Configuration
        const CONFIG = {
            CELL_SIZE: 1,
            SNAKE_SPEED: 220,
            FAST_SPEED: 70,
            NANOBOT_LIFETIME: 5000,
            GROWTH_THRESHOLD: 10,
            OBSTACLE_PER_LEVEL: 3
        };

        // Game State
        let scene, camera, renderer;
        let snake = [];
        let direction = { x: 1, y: 0 };
        let nextDirection = { x: 1, y: 0 };
        let nanobot = null;
        let nanobotTimer = null;
        let nanobotStartTime = 0;
        let obstacles = [];
        let particles = [];
        let score = 0;
        let level = 1;
        let gridWidth, gridHeight;
        let gameRunning = false;
        let lastMoveTime = 0;
        let currentSpeed = CONFIG.SNAKE_SPEED;
        let gridFloor = null;
        let backgroundStars = null;
        let nebulaParticles = [];

        // Touch controls
        let touchStartX = 0;
        let touchStartY = 0;
        let touchThreshold = 30;

        // Snake colors
        const snakeColors = [
            0x00ffff, 0x00eeff, 0x00ddff, 0x00ccff, 0x00bbff,
            0x00aaff, 0x0099ff, 0x0088ff, 0x0077ff, 0x0066ff,
            0x0055ff, 0x0044ff, 0x0033ff, 0x0022ff, 0x0011ff
        ];

        function calculateGridSize() {
            const aspect = window.innerWidth / window.innerHeight;
            // Base size que crece con el nivel
            // Empezamos con celdas MUY GRANDES (pocas celdas)
            const baseSize = 7 + (level - 1) * 3;
            
            if (aspect < 1) {
                // Vertical (mobile 9:16)
                // Queremos que el ancho del grid ocupe casi toda la pantalla
                gridWidth = Math.round(baseSize * 0.85);
                // La altura se calcula proporcionalmente pero dejando espacio arriba para HUD
                gridHeight = Math.round(gridWidth / aspect * 0.82);
            } else {
                // Horizontal (desktop)
                gridHeight = baseSize;
                gridWidth = Math.round(baseSize * aspect * 0.85);
            }
        }

        function initThree() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000510);

            const aspect = window.innerWidth / window.innerHeight;
            // Usar c√°mara de perspectiva para efecto 3D inclinado
            camera = new THREE.PerspectiveCamera(50, aspect, 0.1, 1000);
            camera.position.set(0, 25, 12);
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.getElementById('gameCanvas').appendChild(renderer.domElement);

            // Calcular tama√±o inicial del grid para posicionar c√°mara
            calculateGridSize();

            // Lighting
            const ambientLight = new THREE.AmbientLight(0x334466, 0.8);
            scene.add(ambientLight);

            const topLight = new THREE.DirectionalLight(0xffffff, 0.6);
            topLight.position.set(0, 50, 0);
            scene.add(topLight);

            const cyanLight = new THREE.PointLight(0x00ffff, 1, 100);
            cyanLight.position.set(-20, 20, -20);
            scene.add(cyanLight);

            const magentaLight = new THREE.PointLight(0xff00ff, 1, 100);
            magentaLight.position.set(20, 20, 20);
            scene.add(magentaLight);

            createBackground();
            window.addEventListener('resize', onWindowResize);
        }

        function updateCamera() {
            const aspect = window.innerWidth / window.innerHeight;
            
            // Calculate grid dimensions
            const totalWidth = gridWidth * CONFIG.CELL_SIZE;
            const totalHeight = gridHeight * CONFIG.CELL_SIZE;
            
            // FOV para perspectiva
            camera.fov = 55;
            const fov = camera.fov * (Math.PI / 180);
            
            let cameraHeight, cameraZ, lookAtY, lookAtZ;
            
            if (aspect < 1) {
                // M√≥vil vertical (9:16)
                // Calcular altura para que el mapa quepa perfectamente en pantalla
                // La parte inferior debe quedar visible y la superior justo debajo del HUD
                
                // La c√°mara debe estar lo suficientemente alta para ver todo el ancho
                const requiredHeightForWidth = (totalWidth / 2) / Math.tan(fov / 2) / aspect;
                
                // A√±adir un poco m√°s de altura para la perspectiva inclinada
                cameraHeight = requiredHeightForWidth * 1.05;
                
                // Posici√≥n Z de la c√°mara (hacia el espectador)
                // Esto crea el efecto de perspectiva donde abajo est√° m√°s cerca
                cameraZ = totalHeight * 0.5;
                
                // El punto de mira est√° centrado en Y pero ligeramente hacia arriba en Z
                // Esto hace que la parte superior se vea m√°s peque√±a (m√°s lejos)
                lookAtY = 0;
                lookAtZ = -totalHeight * 0.05;
            } else {
                // Desktop horizontal
                const requiredHeightForWidth = (totalWidth / 2) / Math.tan(fov / 2) / aspect;
                cameraHeight = requiredHeightForWidth * 1.1;
                cameraZ = totalHeight * 0.4;
                lookAtY = 0;
                lookAtZ = -totalHeight * 0.05;
            }
            
            camera.position.set(0, cameraHeight, cameraZ);
            camera.lookAt(0, lookAtY, lookAtZ);
            camera.aspect = aspect;
            camera.updateProjectionMatrix();
        }

        function createBackground() {
            // Dynamic plasma/energy field background
            const bgGeometry = new THREE.PlaneGeometry(500, 500);
            const bgMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    color1: { value: new THREE.Color(0x000520) },
                    color2: { value: new THREE.Color(0x0a0030) },
                    color3: { value: new THREE.Color(0x100040) }
                },
                vertexShader: `
                    varying vec2 vUv;
                    void main() {
                        vUv = uv;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float time;
                    uniform vec3 color1;
                    uniform vec3 color2;
                    uniform vec3 color3;
                    varying vec2 vUv;
                    
                    void main() {
                        vec2 p = vUv * 2.0 - 1.0;
                        float d = length(p);
                        
                        float wave1 = sin(p.x * 3.0 + time * 0.5) * cos(p.y * 3.0 + time * 0.3);
                        float wave2 = sin(p.x * 5.0 - time * 0.4) * sin(p.y * 4.0 + time * 0.6);
                        float wave3 = cos(d * 8.0 - time * 0.8) * 0.5;
                        
                        float pattern = (wave1 + wave2 + wave3) * 0.33 + 0.5;
                        
                        vec3 col = mix(color1, color2, pattern);
                        col = mix(col, color3, sin(d * 4.0 + time * 0.2) * 0.5 + 0.5);
                        
                        // Add subtle glow in center
                        col += vec3(0.0, 0.05, 0.1) * (1.0 - d * 0.5);
                        
                        gl_FragColor = vec4(col, 1.0);
                    }
                `
            });
            const bgPlane = new THREE.Mesh(bgGeometry, bgMaterial);
            bgPlane.rotation.x = -Math.PI / 2;
            bgPlane.position.y = -15;
            bgPlane.userData.isBackground = true;
            scene.add(bgPlane);

            // Animated starfield - multiple layers
            for (let layer = 0; layer < 3; layer++) {
                const starsGeom = new THREE.BufferGeometry();
                const starsCount = 1500;
                const positions = new Float32Array(starsCount * 3);
                const colors = new Float32Array(starsCount * 3);
                const sizes = new Float32Array(starsCount);

                for (let i = 0; i < starsCount; i++) {
                    positions[i * 3] = (Math.random() - 0.5) * 300;
                    positions[i * 3 + 1] = -3 - layer * 3 - Math.random() * 5;
                    positions[i * 3 + 2] = (Math.random() - 0.5) * 300;

                    const colorChoice = Math.random();
                    if (colorChoice < 0.25) {
                        colors[i * 3] = 0; colors[i * 3 + 1] = 1; colors[i * 3 + 2] = 1;
                    } else if (colorChoice < 0.5) {
                        colors[i * 3] = 1; colors[i * 3 + 1] = 0; colors[i * 3 + 2] = 1;
                    } else if (colorChoice < 0.75) {
                        colors[i * 3] = 0.5; colors[i * 3 + 1] = 0.5; colors[i * 3 + 2] = 1;
                    } else {
                        colors[i * 3] = 1; colors[i * 3 + 1] = 1; colors[i * 3 + 2] = 1;
                    }
                    sizes[i] = 0.1 + Math.random() * 0.4;
                }

                starsGeom.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                starsGeom.setAttribute('color', new THREE.BufferAttribute(colors, 3));

                const starsMat = new THREE.PointsMaterial({
                    size: 0.2 + layer * 0.1,
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.9 - layer * 0.2
                });

                const stars = new THREE.Points(starsGeom, starsMat);
                stars.userData.rotSpeed = 0.0002 * (layer + 1);
                stars.userData.isStarLayer = true;
                scene.add(stars);
                if (layer === 0) backgroundStars = stars;
            }

            // Floating energy orbs
            for (let i = 0; i < 25; i++) {
                const orbGeom = new THREE.SphereGeometry(0.3 + Math.random() * 0.5, 16, 16);
                const hue = Math.random();
                const orbMat = new THREE.MeshBasicMaterial({
                    color: new THREE.Color().setHSL(hue, 1, 0.5),
                    transparent: true,
                    opacity: 0.3 + Math.random() * 0.3
                });
                const orb = new THREE.Mesh(orbGeom, orbMat);
                
                const radius = 20 + Math.random() * 40;
                const angle = Math.random() * Math.PI * 2;
                orb.position.set(
                    Math.cos(angle) * radius,
                    -2 - Math.random() * 3,
                    Math.sin(angle) * radius
                );
                orb.userData = {
                    angle: angle,
                    radius: radius,
                    speed: 0.002 + Math.random() * 0.003,
                    ySpeed: 0.01 + Math.random() * 0.02,
                    baseY: orb.position.y,
                    isOrb: true
                };
                scene.add(orb);
                nebulaParticles.push(orb);
            }

            // Electric arc lines
            for (let i = 0; i < 8; i++) {
                const points = [];
                const startAngle = (i / 8) * Math.PI * 2;
                const radius = 35;
                
                for (let j = 0; j <= 20; j++) {
                    const t = j / 20;
                    const angle = startAngle + t * 0.5;
                    points.push(new THREE.Vector3(
                        Math.cos(angle) * radius * (1 + Math.sin(t * Math.PI) * 0.3),
                        -1 - Math.sin(t * Math.PI * 3) * 0.5,
                        Math.sin(angle) * radius * (1 + Math.sin(t * Math.PI) * 0.3)
                    ));
                }
                
                const lineGeom = new THREE.BufferGeometry().setFromPoints(points);
                const lineMat = new THREE.LineBasicMaterial({
                    color: new THREE.Color().setHSL(0.5 + i * 0.05, 1, 0.5),
                    transparent: true,
                    opacity: 0.4
                });
                const line = new THREE.Line(lineGeom, lineMat);
                line.userData.baseAngle = startAngle;
                line.userData.isArc = true;
                scene.add(line);
            }
        }

        function createGrid() {
            if (gridFloor) {
                scene.remove(gridFloor);
            }

            gridFloor = new THREE.Group();

            const totalWidth = gridWidth * CONFIG.CELL_SIZE;
            const totalHeight = gridHeight * CONFIG.CELL_SIZE;

            // Main floor with gradient shader
            const floorGeom = new THREE.PlaneGeometry(totalWidth, totalHeight);
            const floorMat = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    gridSize: { value: new THREE.Vector2(gridWidth, gridHeight) }
                },
                vertexShader: `
                    varying vec2 vUv;
                    void main() {
                        vUv = uv;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float time;
                    uniform vec2 gridSize;
                    varying vec2 vUv;
                    
                    void main() {
                        vec2 grid = vUv * gridSize;
                        vec2 gridLines = abs(fract(grid - 0.5) - 0.5) / fwidth(grid);
                        float line = min(gridLines.x, gridLines.y);
                        
                        // Base color with radial gradient
                        float dist = length(vUv - 0.5);
                        vec3 baseColor = mix(
                            vec3(0.02, 0.04, 0.08),
                            vec3(0.0, 0.01, 0.03),
                            dist * 1.5
                        );
                        
                        // Animated pulse waves
                        float pulse = sin(dist * 20.0 - time * 2.0) * 0.5 + 0.5;
                        pulse *= (1.0 - dist) * 0.3;
                        
                        // Grid glow
                        float gridGlow = 1.0 - min(line, 1.0);
                        vec3 gridColor = mix(
                            vec3(0.0, 0.8, 1.0),
                            vec3(1.0, 0.0, 1.0),
                            sin(time * 0.5 + dist * 3.0) * 0.5 + 0.5
                        );
                        
                        vec3 finalColor = baseColor + gridColor * gridGlow * 0.4 + vec3(0.0, pulse * 0.3, pulse * 0.5);
                        
                        gl_FragColor = vec4(finalColor, 0.95);
                    }
                `,
                transparent: true
            });
            const floor = new THREE.Mesh(floorGeom, floorMat);
            floor.rotation.x = -Math.PI / 2;
            floor.position.y = -0.05;
            floor.userData.isFloor = true;
            gridFloor.add(floor);

            // Animated edge border
            const edgeGeom = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(-totalWidth/2, 0.01, -totalHeight/2),
                new THREE.Vector3(totalWidth/2, 0.01, -totalHeight/2),
                new THREE.Vector3(totalWidth/2, 0.01, totalHeight/2),
                new THREE.Vector3(-totalWidth/2, 0.01, totalHeight/2),
                new THREE.Vector3(-totalWidth/2, 0.01, -totalHeight/2)
            ]);
            const edgeMat = new THREE.LineBasicMaterial({ 
                color: 0x00ffff, 
                transparent: true, 
                opacity: 0.8
            });
            const edge = new THREE.Line(edgeGeom, edgeMat);
            edge.userData.isEdge = true;
            gridFloor.add(edge);

            // Corner markers
            const corners = [
                [-totalWidth/2, -totalHeight/2],
                [totalWidth/2, -totalHeight/2],
                [totalWidth/2, totalHeight/2],
                [-totalWidth/2, totalHeight/2]
            ];
            
            corners.forEach((pos, i) => {
                const markerGeom = new THREE.RingGeometry(0.3, 0.5, 4);
                const markerMat = new THREE.MeshBasicMaterial({
                    color: 0xff00ff,
                    transparent: true,
                    opacity: 0.7,
                    side: THREE.DoubleSide
                });
                const marker = new THREE.Mesh(markerGeom, markerMat);
                marker.rotation.x = -Math.PI / 2;
                marker.rotation.z = Math.PI / 4;
                marker.position.set(pos[0], 0.02, pos[1]);
                marker.userData.cornerIndex = i;
                gridFloor.add(marker);
            });

            scene.add(gridFloor);
        }

        function gridToWorld(gx, gz) {
            const totalWidth = gridWidth * CONFIG.CELL_SIZE;
            const totalHeight = gridHeight * CONFIG.CELL_SIZE;
            return {
                x: (gx + 0.5) * CONFIG.CELL_SIZE - totalWidth / 2,
                z: (gz + 0.5) * CONFIG.CELL_SIZE - totalHeight / 2
            };
        }

        function createSnakeSegment(gx, gz, index, totalLength) {
            const group = new THREE.Group();
            const isHead = index === 0;
            const colorIndex = Math.min(index, snakeColors.length - 1);
            const segmentColor = snakeColors[colorIndex];
            
            const sizeFactor = isHead ? 1 : Math.max(0.5, 1 - index * 0.03);
            const baseRadius = 0.35 * sizeFactor;

            if (isHead) {
                // ===== CABEZA DE SERPIENTE ESTILO KAA =====
                
                // Cabeza principal - forma triangular/ovalada de serpiente
                const headGroup = new THREE.Group();
                
                // Base de la cabeza (forma de gota alargada)
                const headGeom = new THREE.SphereGeometry(0.38, 24, 18);
                headGeom.scale(0.9, 0.55, 1.3); // M√°s alargada y aplanada
                const headMat = new THREE.MeshStandardMaterial({
                    color: 0x00ddaa,
                    metalness: 0.4,
                    roughness: 0.3,
                    emissive: 0x00ffcc,
                    emissiveIntensity: 0.15
                });
                const headBase = new THREE.Mesh(headGeom, headMat);
                headBase.position.y = 0.22;
                headGroup.add(headBase);
                
                // Hocico puntiagudo
                const snoutGeom = new THREE.ConeGeometry(0.22, 0.35, 16);
                snoutGeom.scale(0.8, 1, 1.2);
                const snoutMat = new THREE.MeshStandardMaterial({
                    color: 0x00eebb,
                    metalness: 0.3,
                    roughness: 0.4,
                    emissive: 0x00ffdd,
                    emissiveIntensity: 0.1
                });
                const snout = new THREE.Mesh(snoutGeom, snoutMat);
                snout.rotation.x = Math.PI / 2;
                snout.position.set(0, 0.18, 0.42);
                headGroup.add(snout);
                
                // Cejas/crestas sobre los ojos (aspecto amenazante)
                const browGeom = new THREE.BoxGeometry(0.18, 0.06, 0.12);
                const browMat = new THREE.MeshStandardMaterial({
                    color: 0x008866,
                    metalness: 0.5,
                    roughness: 0.3
                });
                
                const leftBrow = new THREE.Mesh(browGeom, browMat);
                leftBrow.position.set(0.18, 0.38, 0.15);
                leftBrow.rotation.z = -0.3;
                leftBrow.rotation.y = 0.2;
                headGroup.add(leftBrow);
                
                const rightBrow = new THREE.Mesh(browGeom, browMat);
                rightBrow.position.set(-0.18, 0.38, 0.15);
                rightBrow.rotation.z = 0.3;
                rightBrow.rotation.y = -0.2;
                headGroup.add(rightBrow);
                
                // ===== OJOS HIPN√ìTICOS ESTILO KAA =====
                const eyeRadius = 0.14;
                
                // Funci√≥n para crear un ojo hipn√≥tico
                function createHypnoticEye(xPos) {
                    const eyeGroup = new THREE.Group();
                    
                    // Globo ocular (esfera blanca/amarillenta grande)
                    const eyeballGeom = new THREE.SphereGeometry(eyeRadius, 32, 32);
                    const eyeballMat = new THREE.MeshStandardMaterial({
                        color: 0xffffaa,
                        metalness: 0.1,
                        roughness: 0.2,
                        emissive: 0xffff00,
                        emissiveIntensity: 0.3
                    });
                    const eyeball = new THREE.Mesh(eyeballGeom, eyeballMat);
                    eyeGroup.add(eyeball);
                    
                    // Espirales hipn√≥ticas (m√∫ltiples anillos conc√©ntricos)
                    const spiralColors = [0xff00ff, 0x00ffff, 0xff00ff, 0x00ffff, 0xff00ff];
                    for (let i = 0; i < 5; i++) {
                        const ringRadius = eyeRadius * (0.9 - i * 0.15);
                        const spiralGeom = new THREE.TorusGeometry(ringRadius, 0.012, 8, 32);
                        const spiralMat = new THREE.MeshBasicMaterial({
                            color: spiralColors[i],
                            transparent: true,
                            opacity: 0.9 - i * 0.1
                        });
                        const spiral = new THREE.Mesh(spiralGeom, spiralMat);
                        spiral.position.z = 0.01 + i * 0.008;
                        spiral.userData.spiralIndex = i;
                        spiral.userData.isSpiral = true;
                        eyeGroup.add(spiral);
                    }
                    
                    // Pupila central (punto negro con brillo)
                    const pupilGeom = new THREE.CircleGeometry(0.035, 16);
                    const pupilMat = new THREE.MeshBasicMaterial({ 
                        color: 0x000000,
                        side: THREE.DoubleSide
                    });
                    const pupil = new THREE.Mesh(pupilGeom, pupilMat);
                    pupil.position.z = 0.06;
                    eyeGroup.add(pupil);
                    
                    // Brillo en la pupila
                    const glintGeom = new THREE.CircleGeometry(0.015, 8);
                    const glintMat = new THREE.MeshBasicMaterial({ 
                        color: 0xffffff 
                    });
                    const glint = new THREE.Mesh(glintGeom, glintMat);
                    glint.position.set(0.015, 0.015, 0.065);
                    eyeGroup.add(glint);
                    
                    // Borde del ojo (p√°rpado sutil)
                    const lidGeom = new THREE.TorusGeometry(eyeRadius * 1.05, 0.02, 8, 32, Math.PI);
                    const lidMat = new THREE.MeshStandardMaterial({
                        color: 0x006644,
                        metalness: 0.3,
                        roughness: 0.5
                    });
                    const lid = new THREE.Mesh(lidGeom, lidMat);
                    lid.rotation.z = Math.PI;
                    lid.position.z = 0.01;
                    eyeGroup.add(lid);
                    
                    eyeGroup.position.set(xPos, 0.32, 0.22);
                    eyeGroup.rotation.y = xPos > 0 ? 0.25 : -0.25;
                    eyeGroup.userData.isHypnoticEye = true;
                    
                    return eyeGroup;
                }
                
                // Crear ambos ojos
                const leftEye = createHypnoticEye(0.2);
                const rightEye = createHypnoticEye(-0.2);
                headGroup.add(leftEye);
                headGroup.add(rightEye);
                
                // ===== LENGUA B√çFIDA =====
                const tongueGroup = new THREE.Group();
                
                // Base de la lengua
                const tongueBaseGeom = new THREE.CylinderGeometry(0.025, 0.02, 0.25, 8);
                const tongueMat = new THREE.MeshBasicMaterial({ 
                    color: 0xff3366,
                    side: THREE.DoubleSide
                });
                const tongueBase = new THREE.Mesh(tongueBaseGeom, tongueMat);
                tongueBase.rotation.x = Math.PI / 2;
                tongueBase.position.z = 0.12;
                tongueGroup.add(tongueBase);
                
                // Bifurcaci√≥n izquierda
                const forkGeom = new THREE.ConeGeometry(0.018, 0.12, 6);
                const leftFork = new THREE.Mesh(forkGeom, tongueMat);
                leftFork.rotation.x = Math.PI / 2;
                leftFork.rotation.z = 0.4;
                leftFork.position.set(0.04, 0, 0.28);
                tongueGroup.add(leftFork);
                
                // Bifurcaci√≥n derecha
                const rightFork = new THREE.Mesh(forkGeom, tongueMat);
                rightFork.rotation.x = Math.PI / 2;
                rightFork.rotation.z = -0.4;
                rightFork.position.set(-0.04, 0, 0.28);
                tongueGroup.add(rightFork);
                
                tongueGroup.position.set(0, 0.15, 0.45);
                tongueGroup.userData.isTongue = true;
                headGroup.add(tongueGroup);
                
                // ===== ESCAMAS DECORATIVAS EN LA CABEZA =====
                const scaleGeom = new THREE.CircleGeometry(0.04, 6);
                const scaleMat = new THREE.MeshStandardMaterial({
                    color: 0x00aa88,
                    metalness: 0.6,
                    roughness: 0.3,
                    side: THREE.DoubleSide
                });
                
                // Escamas en la parte superior
                for (let i = 0; i < 5; i++) {
                    const scale = new THREE.Mesh(scaleGeom, scaleMat);
                    scale.position.set(
                        (Math.random() - 0.5) * 0.3,
                        0.35 + Math.random() * 0.1,
                        -0.1 - i * 0.08
                    );
                    scale.rotation.x = -Math.PI / 2 + Math.random() * 0.3;
                    scale.rotation.z = Math.random() * Math.PI;
                    headGroup.add(scale);
                }
                
                // ===== FOSAS NASALES =====
                const nostrilGeom = new THREE.CircleGeometry(0.025, 8);
                const nostrilMat = new THREE.MeshBasicMaterial({ color: 0x003322 });
                
                const leftNostril = new THREE.Mesh(nostrilGeom, nostrilMat);
                leftNostril.position.set(0.08, 0.22, 0.52);
                leftNostril.rotation.y = 0.3;
                headGroup.add(leftNostril);
                
                const rightNostril = new THREE.Mesh(nostrilGeom, nostrilMat);
                rightNostril.position.set(-0.08, 0.22, 0.52);
                rightNostril.rotation.y = -0.3;
                headGroup.add(rightNostril);
                
                // ===== ANTENA CYBER (peque√±a y sutil) =====
                const antennaGeom = new THREE.CylinderGeometry(0.015, 0.025, 0.18, 8);
                const antennaMat = new THREE.MeshBasicMaterial({ color: 0x00ffff });
                const antenna = new THREE.Mesh(antennaGeom, antennaMat);
                antenna.position.set(0, 0.48, -0.15);
                headGroup.add(antenna);
                
                const antennaTipGeom = new THREE.SphereGeometry(0.04, 8, 8);
                const antennaTipMat = new THREE.MeshBasicMaterial({ 
                    color: 0xff00ff,
                    transparent: true,
                    opacity: 0.9
                });
                const antennaTip = new THREE.Mesh(antennaTipGeom, antennaTipMat);
                antennaTip.position.set(0, 0.58, -0.15);
                antennaTip.userData.isAntennaTip = true;
                headGroup.add(antennaTip);
                
                group.add(headGroup);

            } else {
                // Body segments
                const bodyGeom = new THREE.SphereGeometry(baseRadius, 12, 10);
                bodyGeom.scale(1, 0.7, 1.1);
                
                const bodyMat = new THREE.MeshStandardMaterial({
                    color: segmentColor,
                    metalness: 0.6,
                    roughness: 0.3,
                    emissive: segmentColor,
                    emissiveIntensity: 0.15
                });
                const body = new THREE.Mesh(bodyGeom, bodyMat);
                body.position.y = 0.2;
                group.add(body);

                // Glowing ring
                const ringGeom = new THREE.TorusGeometry(baseRadius * 0.9, 0.02, 8, 16);
                const ringMat = new THREE.MeshBasicMaterial({
                    color: 0x00ffff,
                    transparent: true,
                    opacity: 0.5 - index * 0.02
                });
                const ring = new THREE.Mesh(ringGeom, ringMat);
                ring.rotation.x = Math.PI / 2;
                ring.position.y = 0.2;
                group.add(ring);
            }

            const worldPos = gridToWorld(gx, gz);
            group.position.set(worldPos.x, 0, worldPos.z);
            group.userData = { gridX: gx, gridZ: gz, index: index };

            scene.add(group);
            return group;
        }

        function createNanobot() {
            if (nanobot) scene.remove(nanobot);

            const group = new THREE.Group();

            // Core
            const coreGeom = new THREE.IcosahedronGeometry(0.3, 1);
            const coreMat = new THREE.MeshStandardMaterial({
                color: 0xff00ff,
                metalness: 0.9,
                roughness: 0.1,
                emissive: 0xff00ff,
                emissiveIntensity: 0.8
            });
            const core = new THREE.Mesh(coreGeom, coreMat);
            group.add(core);

            // Orbiting rings
            for (let i = 0; i < 3; i++) {
                const ringGeom = new THREE.TorusGeometry(0.45 + i * 0.1, 0.02, 8, 32);
                const ringMat = new THREE.MeshBasicMaterial({
                    color: [0xff00ff, 0x00ffff, 0xffff00][i],
                    transparent: true,
                    opacity: 0.8
                });
                const ring = new THREE.Mesh(ringGeom, ringMat);
                ring.rotation.x = Math.PI / 2 + i * 0.4;
                ring.rotation.z = i * 0.5;
                ring.userData.rotSpeed = 0.02 + i * 0.01;
                group.add(ring);
            }

            // Find valid position
            let gx, gz, valid;
            let attempts = 0;
            do {
                gx = Math.floor(Math.random() * gridWidth);
                gz = Math.floor(Math.random() * gridHeight);
                valid = true;
                
                for (const seg of snake) {
                    if (seg.userData.gridX === gx && seg.userData.gridZ === gz) {
                        valid = false;
                        break;
                    }
                }
                for (const obs of obstacles) {
                    if (obs.userData.gridX === gx && obs.userData.gridZ === gz) {
                        valid = false;
                        break;
                    }
                }
                attempts++;
            } while (!valid && attempts < 100);

            const worldPos = gridToWorld(gx, gz);
            group.position.set(worldPos.x, 0.5, worldPos.z);
            group.userData = { gridX: gx, gridZ: gz };

            scene.add(group);
            nanobot = group;

            nanobotStartTime = Date.now();
            if (nanobotTimer) clearTimeout(nanobotTimer);
            nanobotTimer = setTimeout(() => {
                if (nanobot && gameRunning) {
                    createExplosion(nanobot.position.x, nanobot.position.y, nanobot.position.z, 0xff00ff);
                    createNanobot();
                }
            }, CONFIG.NANOBOT_LIFETIME);
        }

        function createObstacle() {
            const group = new THREE.Group();

            const height = 1 + Math.random() * 1.5;
            const obstacleGeom = new THREE.OctahedronGeometry(0.35, 0);
            obstacleGeom.scale(1, height, 1);
            
            const obstacleMat = new THREE.MeshStandardMaterial({
                color: 0xff3300,
                metalness: 0.8,
                roughness: 0.2,
                emissive: 0xff2200,
                emissiveIntensity: 0.4
            });
            const obstacle = new THREE.Mesh(obstacleGeom, obstacleMat);
            obstacle.position.y = height * 0.35;
            group.add(obstacle);

            // Warning ring
            const ringGeom = new THREE.TorusGeometry(0.5, 0.05, 8, 32);
            const ringMat = new THREE.MeshBasicMaterial({
                color: 0xff0000,
                transparent: true,
                opacity: 0.6
            });
            const ring = new THREE.Mesh(ringGeom, ringMat);
            ring.rotation.x = Math.PI / 2;
            ring.position.y = 0.05;
            group.add(ring);

            // Find valid position
            let gx, gz, valid;
            let attempts = 0;
            do {
                gx = Math.floor(Math.random() * gridWidth);
                gz = Math.floor(Math.random() * gridHeight);
                valid = true;
                
                // Check distance from snake head
                if (snake.length > 0) {
                    const head = snake[0];
                    const dist = Math.abs(head.userData.gridX - gx) + Math.abs(head.userData.gridZ - gz);
                    if (dist < 5) valid = false;
                }
                
                for (const seg of snake) {
                    if (seg.userData.gridX === gx && seg.userData.gridZ === gz) {
                        valid = false;
                        break;
                    }
                }
                for (const obs of obstacles) {
                    if (obs.userData.gridX === gx && obs.userData.gridZ === gz) {
                        valid = false;
                        break;
                    }
                }
                if (nanobot && nanobot.userData.gridX === gx && nanobot.userData.gridZ === gz) {
                    valid = false;
                }
                attempts++;
            } while (!valid && attempts < 100);

            if (attempts >= 100) return;

            const worldPos = gridToWorld(gx, gz);
            group.position.set(worldPos.x, 0, worldPos.z);
            group.userData = { gridX: gx, gridZ: gz };

            scene.add(group);
            obstacles.push(group);
        }

        function createExplosion(x, y, z, color) {
            for (let i = 0; i < 25; i++) {
                const geom = new THREE.SphereGeometry(0.08, 6, 6);
                const mat = new THREE.MeshBasicMaterial({
                    color: new THREE.Color(color),
                    transparent: true,
                    opacity: 1
                });
                const particle = new THREE.Mesh(geom, mat);
                particle.position.set(x, y, z);
                
                const speed = 0.15 + Math.random() * 0.2;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI;
                
                particle.userData = {
                    velocity: new THREE.Vector3(
                        Math.sin(phi) * Math.cos(theta) * speed,
                        Math.cos(phi) * speed * 0.5 + 0.1,
                        Math.sin(phi) * Math.sin(theta) * speed
                    ),
                    life: 1,
                    decay: 0.02 + Math.random() * 0.01
                };
                
                scene.add(particle);
                particles.push(particle);
            }
        }

        function initGame() {
            // Clear previous game
            snake.forEach(s => scene.remove(s));
            snake = [];
            obstacles.forEach(o => scene.remove(o));
            obstacles = [];
            particles.forEach(p => scene.remove(p));
            particles = [];
            if (nanobot) scene.remove(nanobot);
            nanobot = null;

            score = 0;
            level = 1;
            direction = { x: 1, y: 0 };
            nextDirection = { x: 1, y: 0 };
            currentSpeed = CONFIG.SNAKE_SPEED;

            calculateGridSize();
            createGrid();
            updateCamera();
            updateUI();

            // Start snake in center
            const startX = Math.floor(gridWidth / 2);
            const startZ = Math.floor(gridHeight / 2);

            snake.push(createSnakeSegment(startX, startZ, 0, 3));
            snake.push(createSnakeSegment(startX - 1, startZ, 1, 3));
            snake.push(createSnakeSegment(startX - 2, startZ, 2, 3));

            // Orientar la cabeza hacia la direcci√≥n inicial (derecha)
            snake[0].rotation.y = Math.PI / 2;

            createNanobot();
            gameRunning = true;
            lastMoveTime = Date.now();
        }

        function updateSnake() {
            const now = Date.now();
            if (now - lastMoveTime < currentSpeed) return;
            lastMoveTime = now;

            direction = { ...nextDirection };

            const head = snake[0];
            let newX = head.userData.gridX + direction.x;
            let newZ = head.userData.gridZ + direction.y;

            // Wrap around edges (no walls!)
            if (newX < 0) newX = gridWidth - 1;
            if (newX >= gridWidth) newX = 0;
            if (newZ < 0) newZ = gridHeight - 1;
            if (newZ >= gridHeight) newZ = 0;

            // Check self collision
            for (let i = 1; i < snake.length; i++) {
                if (snake[i].userData.gridX === newX && snake[i].userData.gridZ === newZ) {
                    gameOver();
                    return;
                }
            }

            // Check obstacle collision
            for (const obs of obstacles) {
                if (obs.userData.gridX === newX && obs.userData.gridZ === newZ) {
                    gameOver();
                    return;
                }
            }

            // Check nanobot collection
            let grow = false;
            if (nanobot && nanobot.userData.gridX === newX && nanobot.userData.gridZ === newZ) {
                grow = true;
                score++;
                
                createExplosion(nanobot.position.x, nanobot.position.y, nanobot.position.z, 0xff00ff);
                scene.remove(nanobot);
                nanobot = null;
                clearTimeout(nanobotTimer);

                // Level up every 10 nanobots
                if (score % CONFIG.GROWTH_THRESHOLD === 0) {
                    levelUp();
                } else {
                    createNanobot();
                }

                updateUI();
            }

            // Move snake
            const positions = [{ x: newX, z: newZ }];
            snake.forEach(seg => {
                positions.push({ x: seg.userData.gridX, z: seg.userData.gridZ });
            });

            snake.forEach(seg => scene.remove(seg));
            snake = [];

            const newLength = grow ? positions.length : positions.length - 1;
            for (let i = 0; i < newLength; i++) {
                snake.push(createSnakeSegment(positions[i].x, positions[i].z, i, newLength));
            }

            // Update head rotation based on direction
            // La cabeza est√° construida mirando hacia +Z, as√≠ que ajustamos la rotaci√≥n
            if (direction.x === 1) {
                snake[0].rotation.y = Math.PI / 2;  // Derecha
            } else if (direction.x === -1) {
                snake[0].rotation.y = -Math.PI / 2; // Izquierda
            } else if (direction.y === -1) {
                snake[0].rotation.y = Math.PI;      // Arriba (hacia -Z en pantalla)
            } else if (direction.y === 1) {
                snake[0].rotation.y = 0;            // Abajo (hacia +Z en pantalla)
            }

            document.getElementById('length').textContent = snake.length;
        }

        function levelUp() {
            level++;
            
            // Show level up message
            const levelUpEl = document.getElementById('levelUp');
            levelUpEl.textContent = `¬°NIVEL ${level}!`;
            levelUpEl.classList.add('active');
            setTimeout(() => levelUpEl.classList.remove('active'), 1500);

            // Store snake ABSOLUTE grid positions (not relative)
            const snakeGridPositions = snake.map(seg => ({
                gx: seg.userData.gridX,
                gz: seg.userData.gridZ
            }));
            
            // Store old grid size
            const oldGridWidth = gridWidth;
            const oldGridHeight = gridHeight;

            // Expand grid
            calculateGridSize();
            
            // Calculate how much the grid expanded
            const deltaWidth = gridWidth - oldGridWidth;
            const deltaHeight = gridHeight - oldGridHeight;
            
            // El mapa crece hacia ABAJO (Z positivo es abajo en pantalla)
            // La serpiente y obst√°culos existentes se mantienen arriba
            // offsetX centra horizontalmente, offsetZ = 0 para que crezca hacia abajo
            const offsetX = Math.floor(deltaWidth / 2);
            const offsetZ = 0; // No desplazamos en Z, el mapa crece hacia abajo
            
            createGrid();
            updateCamera();

            // Reposition snake - se mantiene arriba (mismas coordenadas Z, solo ajuste X)
            snake.forEach(seg => scene.remove(seg));
            snake = [];
            
            snakeGridPositions.forEach((pos, i) => {
                const newX = pos.gx + offsetX;
                const newZ = pos.gz; // Mantener Z sin cambios (arriba)
                snake.push(createSnakeSegment(newX, newZ, i, snakeGridPositions.length));
            });

            // Mantener la orientaci√≥n de la cabeza seg√∫n la direcci√≥n actual
            if (direction.x === 1) {
                snake[0].rotation.y = Math.PI / 2;
            } else if (direction.x === -1) {
                snake[0].rotation.y = -Math.PI / 2;
            } else if (direction.y === -1) {
                snake[0].rotation.y = Math.PI;
            } else if (direction.y === 1) {
                snake[0].rotation.y = 0;
            }

            // Reposition existing obstacles - tambi√©n se mantienen arriba
            const obstacleGridPositions = obstacles.map(obs => ({
                gx: obs.userData.gridX,
                gz: obs.userData.gridZ
            }));
            
            obstacles.forEach(obs => scene.remove(obs));
            obstacles = [];
            
            obstacleGridPositions.forEach(pos => {
                const newGx = pos.gx + offsetX;
                const newGz = pos.gz; // Mantener Z sin cambios (arriba)
                
                const group = createObstacleAt(newGx, newGz);
                if (group) obstacles.push(group);
            });

            // Add new obstacles ONLY in the new bottom area
            for (let i = 0; i < CONFIG.OBSTACLE_PER_LEVEL; i++) {
                createObstacleInBottomZone(oldGridHeight, deltaHeight);
            }

            createNanobot();
            document.getElementById('level').textContent = level;
        }
        
        // Funci√≥n para crear obst√°culos solo en la zona nueva de abajo
        function createObstacleInBottomZone(oldHeight, deltaHeight) {
            const group = new THREE.Group();

            const height = 1 + Math.random() * 1.5;
            const obstacleGeom = new THREE.OctahedronGeometry(0.35, 0);
            obstacleGeom.scale(1, height, 1);
            
            const obstacleMat = new THREE.MeshStandardMaterial({
                color: 0xff3300,
                metalness: 0.8,
                roughness: 0.2,
                emissive: 0xff2200,
                emissiveIntensity: 0.4
            });
            const obstacle = new THREE.Mesh(obstacleGeom, obstacleMat);
            obstacle.position.y = height * 0.35;
            group.add(obstacle);

            const ringGeom = new THREE.TorusGeometry(0.5, 0.05, 8, 32);
            const ringMat = new THREE.MeshBasicMaterial({
                color: 0xff0000,
                transparent: true,
                opacity: 0.6
            });
            const ring = new THREE.Mesh(ringGeom, ringMat);
            ring.rotation.x = Math.PI / 2;
            ring.position.y = 0.05;
            group.add(ring);

            // Solo buscar posici√≥n en la zona NUEVA (parte inferior del mapa)
            let gx, gz, valid;
            let attempts = 0;
            do {
                gx = Math.floor(Math.random() * gridWidth);
                // Solo en la zona nueva de abajo (desde oldHeight hasta gridHeight)
                gz = oldHeight + Math.floor(Math.random() * deltaHeight);
                valid = true;
                
                for (const seg of snake) {
                    if (seg.userData.gridX === gx && seg.userData.gridZ === gz) {
                        valid = false;
                        break;
                    }
                }
                for (const obs of obstacles) {
                    if (obs.userData.gridX === gx && obs.userData.gridZ === gz) {
                        valid = false;
                        break;
                    }
                }
                if (nanobot && nanobot.userData.gridX === gx && nanobot.userData.gridZ === gz) {
                    valid = false;
                }
                attempts++;
            } while (!valid && attempts < 100);

            if (attempts >= 100) return;

            const worldPos = gridToWorld(gx, gz);
            group.position.set(worldPos.x, 0, worldPos.z);
            group.userData = { gridX: gx, gridZ: gz };

            scene.add(group);
            obstacles.push(group);
        }

        function createObstacleAt(gx, gz) {
            const group = new THREE.Group();

            const height = 1 + Math.random() * 1.5;
            const obstacleGeom = new THREE.OctahedronGeometry(0.35, 0);
            obstacleGeom.scale(1, height, 1);
            
            const obstacleMat = new THREE.MeshStandardMaterial({
                color: 0xff3300,
                metalness: 0.8,
                roughness: 0.2,
                emissive: 0xff2200,
                emissiveIntensity: 0.4
            });
            const obstacle = new THREE.Mesh(obstacleGeom, obstacleMat);
            obstacle.position.y = height * 0.35;
            group.add(obstacle);

            const ringGeom = new THREE.TorusGeometry(0.5, 0.05, 8, 32);
            const ringMat = new THREE.MeshBasicMaterial({
                color: 0xff0000,
                transparent: true,
                opacity: 0.6
            });
            const ring = new THREE.Mesh(ringGeom, ringMat);
            ring.rotation.x = Math.PI / 2;
            ring.position.y = 0.05;
            group.add(ring);

            const worldPos = gridToWorld(gx, gz);
            group.position.set(worldPos.x, 0, worldPos.z);
            group.userData = { gridX: gx, gridZ: gz };

            scene.add(group);
            return group;
        }

        function gameOver() {
            gameRunning = false;
            
            snake.forEach(seg => {
                createExplosion(seg.position.x, seg.position.y + 0.3, seg.position.z, 0x00ffff);
            });

            document.getElementById('finalScore').textContent = score;
            setTimeout(() => {
                document.getElementById('gameOverScreen').style.display = 'flex';
            }, 500);
        }

        function updateUI() {
            document.getElementById('score').textContent = score;
            document.getElementById('length').textContent = snake.length;
            document.getElementById('level').textContent = level;
        }

        function updateTimerDisplay() {
            if (!nanobot || !gameRunning) return;
            
            const elapsed = Date.now() - nanobotStartTime;
            const remaining = Math.max(0, CONFIG.NANOBOT_LIFETIME - elapsed);
            const percent = (remaining / CONFIG.NANOBOT_LIFETIME) * 100;
            
            document.getElementById('timerFill').style.width = percent + '%';
        }

        function animate() {
            requestAnimationFrame(animate);

            const time = Date.now() * 0.001;

            if (gameRunning) {
                updateSnake();
                updateTimerDisplay();
            }

            // Animate background shader
            scene.children.forEach(child => {
                if (child.userData.isBackground && child.material.uniforms) {
                    child.material.uniforms.time.value = time;
                }
                if (child.userData.isStarLayer) {
                    child.rotation.y += child.userData.rotSpeed;
                }
                if (child.userData.isArc) {
                    child.rotation.y += 0.002;
                }
            });

            // Animate floating orbs
            nebulaParticles.forEach((orb, i) => {
                const data = orb.userData;
                if (data.isOrb) {
                    data.angle += data.speed;
                    orb.position.x = Math.cos(data.angle) * data.radius;
                    orb.position.z = Math.sin(data.angle) * data.radius;
                    orb.position.y = data.baseY + Math.sin(time * data.ySpeed * 50 + i) * 1.5;
                    
                    // Pulse opacity
                    orb.material.opacity = 0.3 + Math.sin(time * 2 + i) * 0.2;
                }
            });

            // Animate nanobot
            if (nanobot) {
                nanobot.rotation.y += 0.03;
                nanobot.position.y = 0.5 + Math.sin(time * 4) * 0.15;

                nanobot.children.forEach(child => {
                    if (child.userData.rotSpeed) {
                        child.rotation.z += child.userData.rotSpeed;
                    }
                });
            }

            // Animate obstacles
            obstacles.forEach((obs, i) => {
                if (obs.children[0]) obs.children[0].rotation.y += 0.01;
                if (obs.children[1]) {
                    const pulse = 1 + Math.sin(time * 3 + i) * 0.1;
                    obs.children[1].scale.setScalar(pulse);
                }
            });

            // Animate snake
            if (snake.length > 0) {
                // Animar la cabeza (primer segmento)
                const headGroup = snake[0].children[0];
                if (headGroup && headGroup.children) {
                    headGroup.children.forEach(child => {
                        // Animar lengua b√≠fida (movimiento de entrada/salida)
                        if (child.userData && child.userData.isTongue) {
                            child.position.z = 0.45 + Math.sin(time * 12) * 0.15;
                            child.rotation.y = Math.sin(time * 8) * 0.1;
                        }
                        
                        // Animar ojos hipn√≥ticos
                        if (child.userData && child.userData.isHypnoticEye) {
                            child.children.forEach(eyePart => {
                                if (eyePart.userData && eyePart.userData.isSpiral) {
                                    // Rotar espirales en direcciones alternadas
                                    const dir = eyePart.userData.spiralIndex % 2 === 0 ? 1 : -1;
                                    eyePart.rotation.z = time * 3 * dir + eyePart.userData.spiralIndex * 0.5;
                                    
                                    // Pulsar tama√±o
                                    const pulse = 1 + Math.sin(time * 4 + eyePart.userData.spiralIndex) * 0.1;
                                    eyePart.scale.setScalar(pulse);
                                }
                            });
                        }
                        
                        // Animar punta de antena
                        if (child.userData && child.userData.isAntennaTip) {
                            child.material.opacity = 0.5 + Math.sin(time * 6) * 0.4;
                            const glowScale = 1 + Math.sin(time * 8) * 0.3;
                            child.scale.setScalar(glowScale);
                        }
                    });
                }

                // Animar cuerpo (movimiento ondulatorio)
                snake.forEach((seg, i) => {
                    if (i > 0) {
                        seg.position.y = Math.sin(time * 5 + i * 0.4) * 0.05;
                    }
                });
            }

            // Animate floor shader
            if (gridFloor) {
                gridFloor.children.forEach(child => {
                    if (child.userData.isFloor && child.material.uniforms) {
                        child.material.uniforms.time.value = time;
                    }
                    if (child.userData.isEdge) {
                        child.material.opacity = 0.5 + Math.sin(time * 3) * 0.3;
                    }
                    if (child.userData.cornerIndex !== undefined) {
                        child.rotation.z = Math.PI / 4 + time * 0.5 + child.userData.cornerIndex * 0.5;
                        child.scale.setScalar(1 + Math.sin(time * 2 + child.userData.cornerIndex) * 0.2);
                    }
                });
            }

            // Update particles
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.position.add(p.userData.velocity);
                p.userData.velocity.y -= 0.005;
                p.userData.life -= p.userData.decay;
                p.material.opacity = p.userData.life;

                if (p.userData.life <= 0) {
                    scene.remove(p);
                    particles.splice(i, 1);
                }
            }

            renderer.render(scene, camera);
        }

        function onWindowResize() {
            const aspect = window.innerWidth / window.innerHeight;
            renderer.setSize(window.innerWidth, window.innerHeight);
            
            if (gridWidth && gridHeight) {
                updateCamera();
            }
        }

        // Keyboard controls
        document.addEventListener('keydown', (e) => {
            if (!gameRunning) return;

            switch (e.key.toLowerCase()) {
                case 'arrowup': case 'w':
                    if (direction.y !== 1) nextDirection = { x: 0, y: -1 };
                    break;
                case 'arrowdown': case 's':
                    if (direction.y !== -1) nextDirection = { x: 0, y: 1 };
                    break;
                case 'arrowleft': case 'a':
                    if (direction.x !== 1) nextDirection = { x: -1, y: 0 };
                    break;
                case 'arrowright': case 'd':
                    if (direction.x !== -1) nextDirection = { x: 1, y: 0 };
                    break;
                case ' ':
                    currentSpeed = CONFIG.FAST_SPEED;
                    break;
            }
        });

        document.addEventListener('keyup', (e) => {
            if (e.key === ' ') {
                currentSpeed = CONFIG.SNAKE_SPEED;
            }
        });

        // Touch/Swipe controls
        document.addEventListener('touchstart', (e) => {
            touchStartX = e.touches[0].clientX;
            touchStartY = e.touches[0].clientY;
        }, { passive: false });

        document.addEventListener('touchmove', (e) => {
            e.preventDefault();
        }, { passive: false });

        document.addEventListener('touchend', (e) => {
            if (!gameRunning) return;

            const touchEndX = e.changedTouches[0].clientX;
            const touchEndY = e.changedTouches[0].clientY;
            
            const deltaX = touchEndX - touchStartX;
            const deltaY = touchEndY - touchStartY;
            
            if (Math.abs(deltaX) < touchThreshold && Math.abs(deltaY) < touchThreshold) {
                return;
            }

            if (Math.abs(deltaX) > Math.abs(deltaY)) {
                // Horizontal swipe
                if (deltaX > 0 && direction.x !== -1) {
                    nextDirection = { x: 1, y: 0 };
                } else if (deltaX < 0 && direction.x !== 1) {
                    nextDirection = { x: -1, y: 0 };
                }
            } else {
                // Vertical swipe
                if (deltaY > 0 && direction.y !== -1) {
                    nextDirection = { x: 0, y: 1 };
                } else if (deltaY < 0 && direction.y !== 1) {
                    nextDirection = { x: 0, y: -1 };
                }
            }
        }, { passive: false });

        // Button events
        document.getElementById('startBtn').addEventListener('click', () => {
            document.getElementById('startScreen').style.display = 'none';
            initGame();
        });

        document.getElementById('restartBtn').addEventListener('click', () => {
            document.getElementById('gameOverScreen').style.display = 'none';
            initGame();
        });

        // D-Pad controls
        const dpadButtons = {
            btnUp: { x: 0, y: -1 },
            btnDown: { x: 0, y: 1 },
            btnLeft: { x: -1, y: 0 },
            btnRight: { x: 1, y: 0 }
        };

        Object.entries(dpadButtons).forEach(([id, dir]) => {
            const btn = document.getElementById(id);
            
            // Touch events
            btn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                if (!gameRunning) return;
                btn.classList.add('active');
                
                // Verificar que no vaya en direcci√≥n opuesta
                if (dir.x !== 0 && direction.x !== -dir.x) {
                    nextDirection = { ...dir };
                } else if (dir.y !== 0 && direction.y !== -dir.y) {
                    nextDirection = { ...dir };
                }
            }, { passive: false });

            btn.addEventListener('touchend', (e) => {
                e.preventDefault();
                btn.classList.remove('active');
            }, { passive: false });

            // Mouse events (for desktop testing)
            btn.addEventListener('mousedown', (e) => {
                if (!gameRunning) return;
                btn.classList.add('active');
                
                if (dir.x !== 0 && direction.x !== -dir.x) {
                    nextDirection = { ...dir };
                } else if (dir.y !== 0 && direction.y !== -dir.y) {
                    nextDirection = { ...dir };
                }
            });

            btn.addEventListener('mouseup', () => {
                btn.classList.remove('active');
            });

            btn.addEventListener('mouseleave', () => {
                btn.classList.remove('active');
            });
        });

        // Turbo button
        const turboBtn = document.getElementById('turboBtn');
        
        turboBtn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            turboBtn.classList.add('active');
            currentSpeed = CONFIG.FAST_SPEED;
        }, { passive: false });

        turboBtn.addEventListener('touchend', (e) => {
            e.preventDefault();
            turboBtn.classList.remove('active');
            currentSpeed = CONFIG.SNAKE_SPEED;
        }, { passive: false });

        turboBtn.addEventListener('touchcancel', (e) => {
            turboBtn.classList.remove('active');
            currentSpeed = CONFIG.SNAKE_SPEED;
        }, { passive: false });

        // Mouse events for turbo (desktop testing)
        turboBtn.addEventListener('mousedown', (e) => {
            turboBtn.classList.add('active');
            currentSpeed = CONFIG.FAST_SPEED;
        });

        turboBtn.addEventListener('mouseup', () => {
            turboBtn.classList.remove('active');
            currentSpeed = CONFIG.SNAKE_SPEED;
        });

        turboBtn.addEventListener('mouseleave', () => {
            turboBtn.classList.remove('active');
            currentSpeed = CONFIG.SNAKE_SPEED;
        });

        // Hide touch controls on start screen, show during game
        function updateTouchControlsVisibility() {
            const touchControls = document.getElementById('touchControls');
            const startScreen = document.getElementById('startScreen');
            const gameOverScreen = document.getElementById('gameOverScreen');
            
            if (startScreen.style.display !== 'none' || gameOverScreen.style.display !== 'none') {
                touchControls.style.display = 'none';
            } else {
                touchControls.style.display = 'flex';
            }
        }

        // Override button clicks to also update touch controls visibility
        const originalStartClick = document.getElementById('startBtn').onclick;
        document.getElementById('startBtn').addEventListener('click', () => {
            setTimeout(updateTouchControlsVisibility, 100);
        });

        document.getElementById('restartBtn').addEventListener('click', () => {
            setTimeout(updateTouchControlsVisibility, 100);
        });

        // Initially hide touch controls
        document.getElementById('touchControls').style.display = 'none';

        // Initialize
        initThree();
        calculateGridSize();
        updateCamera();
        animate();
    </script>
</body>
</html>
